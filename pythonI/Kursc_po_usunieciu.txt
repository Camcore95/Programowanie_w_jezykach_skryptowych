1. Wprowadzenie do kursu 


S¹ dwa powody, dla których zdecydowa³em napisaæ kurs jêzyka C. Pierwszy jest taki, ¿e nie uda³o mznaleŸæ w internecie strony, która zawiera³aby takkurs w jêzyku polskim. Owszem, mo¿na znaleŸæ kilka tego typu publikacji, ale wszystkie s¹ napisane w jêzyku angielskim. Drugiego powodu, który sk³oni³ mnie do tego kroku nie zdradzê, ale pewna grupa ludzwie o co chodz(sorry, ¿e tak wysz³o, ale samchcieliœcie ;) PrzejdŸmy wreszcie do rzeczy... 

Na wstêpie chcia³bym przedstawiæ za³o¿enia, jakie przyj¹³em odnoœnie Twojej wiedzy  kilka ogólnych informacjdotycz¹cych jêzyka C. 

Jêzyk C, podobnie jak Pascal, jest jêzykiem strukturalnym. Jednak w przeciwieñstwie do Pascala jest on o wiele mniej rygorystyczny w stosunku do programisty, dziêkczemu osoba pisz¹ca program w C ma o wiele wiêksz¹ swobodê dzia³ania. Poza tym jêzyk ten jest bardziej kompaktowy - w jednej linijce programu w C mo¿na zawrzeæ to, co w przypadku Pascala zajê³oby dziesiêæ. Niektórzy uwa¿aj¹ to za wadê, bo powoduje to trudnoœcw póŸniejszym analizowaniu kodu programu, jednak wed³ug mnie jest to ogromna zaleta tego jêzyka. To programista decyduje tu jak ma wygl¹daæ jego program - jeœlchce czysty, przejrzysty kod to pisze dziesiêæ linijek kodu, ale jeœlwygodniej jest mu to samo zawrzeæ w jednej linijce to  standard jêzyka mia³by go ograniczaæ ? 

Jednak mimo tego (a mo¿e w³aœnie dlatego) s¹dzê, ¿e jêzyk C nie powinien byæ pierwszym jêzykiem programowania, który poznaje. Wed³ug mnie powinno zacz¹æ o bardziej "szkoleniowego" jêzyka jakim jest Pascal. Dopiero po zapoznaniu z ogólnymkoncepcjamprogramowania mo¿na myœleæ o rozpoczêciu naukjêzyka C. Dlatego te¿ nie bêdê w tym kursie t³umaczy³ takich podstawowych pojêæ jak np. zmienna. Zak³adam, ¿e masz ju¿ ogólne pojêcie o programowaniu. Do zrozumienia tego kursu nie bêdzie jednak konieczna znajomoœæ Pascala, mo¿e to byæ dowolny inny jêzyk programowania. Bêdzie to jednak bardzo pomocne, gdy¿ czêsto bêdê podawa³ odpowiednikdanej instrukcjw³aœnie w tym jêzyku. Powinieneœ tak¿e pamiêtaæ, ¿e samo przeczytanie tego kursu nic Cnie da. Ja przeka¿ê Ctylko koncepcjê jêzyka, jego s³owa kluczowe przyk³ady ich zastosowania, jednak umiejêtnoœæ praktycznego ich wykorzystania nabêdziesz tylko wy³¹cznie podczas samodzielnego pisania programów w jêzyku C. Tak wiêc pamiêtaj - æwiczyæ, æwiczyæ jeszcze raz æwiczyæ ! 

Do³o¿y³em wszelkich starañ, aby kurs ten w sposób jasny czytelny przedstawia³ zasady pisania w jêzyku C. Jeœljednak coœ jest nie do koñca zrozumia³e to mo¿esz do mnie napisaæ. Mój email to motzel@panda.bg.univ.gda.pl lub motzel@polbox.com. Preferujê ten pierwszy, jeœljednak on nie dzia³a (bo na przyk³ad obla³em jakiœ egzamin wyrzucilmnie ze studiów ;) to napisz na drugi. Postaram w miarê mo¿liwoœcwyt³umaczyæ dane zagadnienie. Proszê jednak, ¿ebyœ z pytaniamwstrzyma³ a¿ do momentu, gdy przeczytasz punkt "Mój pierwszy program". Do tego momentu coœ mo¿e wydawaæ niejasne poniewa¿ brak jest odpowiednich przyk³adów, jednak ten pierwszy program powinien rozwiaæ wszelkie w¹tpliwoœci. 
Mam te¿ proœbê do osób znaj¹cych ju¿ jêzyk C, a czytaj¹cych ten kurs (s¹ tacy ?). JeœlznaleŸliœcie jakieœ nieœcis³oœclub te¿ po prostu b³êdy, to proszê o informacjê, abym móg³ to poprawiæ. 

Wszystkie przyk³adowe programy przedstawione w tym kursie by³y kompilowane przy u¿yciu DJGPP (jest to dosowa wersja gcc, znanego z systemów unixowych), jednak powinny kompilowaæ bez problemu przy u¿yciu dowolnego innego kompilatora C. Mo¿esz je zsci¹gn¹æ w postacpliku zip. Zak³adaj¹c, ¿e u¿ywasz tego samego kompilatora, aby skompilowaæ te plikmusisz wydaæ polecenie: 
gcc nazwa.c -o nazwa.exe
Po poprawnej kompilacjna dysku zostanie utworzony plik exe, który jest gotowym do uruchomienia programem. 




2. Wprowadzenie do jêzyka C 


Program w jêzyku C jest podzielony na blokzawarte miêdzy nawiasamklamrowym{ } (s¹ to odpowiednik"begin" "end" z Pascala). Ka¿dy blok mo¿e byæ kompletn¹ funkcj¹, albo po prostu fragmentem kodu w ramach danej funkcji. Funkcja jest to po prostu wydzielona cz¹stka programu, która wykonuje jakieœ zadanie (np. oblicza pole powierzchnprostok¹ta o danych bokach). W ka¿dym programie napisanym w jêzyku C musznaleŸæ funkcja o nazwie "main". Jest to g³ówna programu, od której zaczyna on swój bieg. Najprostszy program w jêzyku C wygl¹da wiêc tak: 

void main(void)
{
}
Pomiñmy na razie s³ówko "void" (przejdziemy do tego w nastêpnym punkcie) przeanalizujmy ten program. Mamy tutaj jedn¹, jedyn¹ funkcjê "main", która w naszym przypadku nie zawiera ¿adnego kodu (czylnic nie robi). Jak widzimy definicja funkcjsk³ada z nag³ówka, który okreœla jej nazwê, parametry wejœciowe rodzaj zwracanej wartoœc(to tak¿e omówimy póŸniej)  z w³aœciwego cia³a funkcjzawartego miêdzy { } . Zapisuj¹c to inaczej definicja funkcjwygl¹da to tak: 
typ_zwracanej_wartoœcnazwa_funkcji(lista parametrów)
{
}
Analogiczna definicja funkcjw Pascalu wygl¹da tak: 
function nazwa_funkcji(lista parametrów) : typ_zwracanej_wartoœci;
begin
end;
Podobne, prawda ? 

Na uwagê zas³uguje jeszcze fakt, ¿e po nazwie funkcjw jêzyku C nie stawiamy œrednika, tak jak to by³o w Pascalu. Jest to sensowne poniewa¿ œrednik symbolizuje zakoñczenie pewnej logicznej ca³oœci, a tu mamy do czynienia z sytuacj¹ wrêcz przeciwn¹ - od tego miejsca funkcja zaczyna, nie koñczy. 

Na zakoñczenie tego punktu powiemy sobie jeszcze o zasadach konstrukcjnazw funkcj(tyczy to tak¿e nazw zmiennych, o których bêdzie nastêpny punkt). W jêzyku C ka¿dy identyfikator muszaczynaæ od litery, albo od podkreœlenia dolnego "_". Pozosta³e znakidentyfikatora mog¹ oprócz liter "_" zawieraæ tak¿e cyfry. D³ugoœæ jest ograniczona do 32 znaków (mo¿e byæ wiêksza, ale pozosta³e znaks¹ po prostu ignorowane). I tutaj wa¿na uwaga: jêzyk C rozró¿nia wielkoœæ liter, tak wiêc "PoleProstokata" "poleprostokata" to dwie ró¿ne nazwy ! Szczególnie musz¹ uwa¿aæ osoby, które pisa³y wczeœniej w jêzyku Pascal (w którym jest brak takiego rozró¿nienia), gdy¿ mo¿e prowadziæ to do trudnych do zlokalizowania b³êdów. 




3. Typy danych 


W jêzyku C s¹ cztery podstawowe proste typy danych: znak, liczba ca³kowita, liczba rzeczywista typ bezwartoœciowy. Typy te mo¿na nieco zmodyfikowaæ poprzez dodanie przy deklaracjnastêpuj¹cych s³ów: "signed", aby uzyskaæ liczbê ze znakiem (jest to ustawienie domyœlne); "unsigned", aby uzyskaæ liczbê bez znaku; "short", aby zmniejszyæ wielkoœæ zmiennej (ale zmniejszeniu ulega tak¿e zakres); "long", aby zwiêkszyæ wielkoœæ zmiennej (zwiêkszeniu ulega zakres, ale zmienna zajmuje wiêcej miejsca w pamiêci). 

Poni¿sza tabela zawiera wspomniane typy: 

Nazwa typu
Typ
Zakres
Wielkoœæ (w bajtach)
Uwagi
char
ca³kowity
-128..127
1

unsigned char
ca³kowity
0..255
1

int
ca³kowity
-2^31..2^31-1
4
Na kompilatorach 16 bitowych ma 2 bajty
unsigned int
ca³kowity
0..2^32
4
Na kompilatorach 16 bitowych ma 2 bajty
short int
ca³kowity
-32768..32767
2

unsigned short int
ca³kowity
0..65535
2

long int
ca³kowity
-2^31..2^31-1
4

unsigned long int
ca³kowity
0..2^32
4

float
rzeczywisty
6 znaków precyzji
4

double
rzeczywisty
10 znaków precyzji
8


Jak widaæ w przypadku wielkoœæ zmiennej mierzona w bajtach jest wprost proporcjonalna do zakresu danych, jakmo¿e ona przechowywaæ. Dla zmiennych ca³kowitych zakres ten wynosod 0 do 2^n (w przypadku liczb bez znaku), lub od -2^n do 2^n-1 (w przypadku liczb ze znakiem), gdzie n to iloœæ _bitów_ na których zapisana jest zmienna. Dla przypomnienia: jeden bajt ma osiem bitów... 

Deklaracja zmiennej wygl¹da tak: 

typ_danych nazwa_zmiennej; (czyldok³adnie odwrotnie ni¿ w Pascalu, w którym by³o: "nazwa_zmiennej : typ_danych;") 


Czyli, jeœlchcemy zadeklarowaæ zmienn¹ znakow¹ o nazwie "znak" to robimy to w ten sposób: 

char znak; 

W tym miejscu muszê tak¿e przedstawiæ jeden z wa¿niejszych operatorów jêzyka C (pozosta³e zostan¹ opisane w nastêpnych punktach). Jest to oczywiœcie operator przypisania "=". Zapewne ju¿ wiesz do czego on s³u¿y, ale dla dope³nienia formalnoœcnapiszê, ¿e przypisuje wartoœæ wyra¿enia z lewej strony do zmiennej umiejscowionej po prawej jego stronie. Operator ten to oczywiœcie odpowiednik Pascalowego ":=". Od razu przedstawiê praktyczne jego zastosowanie - zadeklarujemy zmienna tak¹, jak w powy¿szym przyk³adzie przypiszemy jej wartoœæ pocz¹tkow¹: 

char znak='A'; 

Konstrukcja taka nie wystêpuje w Pascalu, gdzie blok deklaracjzmiennych jest wydzielony trzeba do osi¹gniêcia tego samego celu wpisaæ dwie linijkkodu. 


Deklaracja zmiennej ca³kowitej o nazwie "dlugosc" (wraz z przypisaniem jej wartoœcpocz¹tkowej) wygl¹da tak: 

unsigned long int dlugosc=5; 


Natomiast deklaracja zmiennej rzeczywistej o nazwie "pole" (wraz z przypisaniem jej wartoœcpocz¹tkowej) tak: 

float pole=3.48; 

Jak widzimy w powy¿szym przyk³adzie czêœæ ca³kowit¹ oddzielamy od czêœcu³amkowej przy pomocy kropki, nie przecinka ! 


Tutaj wa¿na uwaga. Deklaracja wszystkich zmiennych musbyæ wpisana na logicznego pocz¹tku bloku programu (czylzaraz za znakiem { , który to takblok rozpoczyna). Zmienna taka jest lokalna, czyljest dostêpna tylko wewn¹trz bloku, w którym jest zadeklarowana. 

Do omówienia pozosta³ jeszcze typ bezwartoœciowy - jak zapewne domyœlacie, jest to wspomniane w poprzednim punkcie "void". Nie jest to typ danych w œcis³ym tego s³owa znaczeniu poniewa¿ nie mo¿na utworzyæ zmiennej tego typu (mo¿na jednak utworzyæ zmienn¹ typu wskaŸnik na void, ale to omówiê gdzieœ pod koniec tego kursu). S³u¿y on g³ownie do deklaracji, ¿e funkcja nie zwraca lub te¿ nie przyjmuje ¿adnych danych. Czylprzyk³ad z pierwszego punktu: 

void main(void) 

mo¿na przet³umaczyæ jako informacjê dla kompilatora, ¿e chcemy zdefiniowaæ funkcjê o nazwie "main", która nie zwraca ¿adnej wartoœc nie przyjmuje ¿adnych parametrów. 

Jeœlna razie coœ nie jest jasne to nie martw, w nastêpnym punkcie przedstawiê jeszcze podstawowe operatory arytmetyczne wreszcie bêdziemy ju¿ moglnapisaæ swój pierwszy program, w którym poka¿ê praktyczne zastosowanie przestawionych rzeczy. A dobry przyk³ad jest lepszy ni¿ tysi¹c s³ów.... 




4. Operatory arytmetyczne 


Jêzyk C jest bardzo bogato wyposa¿ony we wszelkiego rodzaju operatory arytmetyczne. Poznaliœmy ju¿ operator przypisania, przysz³a pora na nastêpne. Przedstawiê to w formie tabeli, która bêdzie tak¿e zawieraæ pascalowy odpowiednik. 

C
Pascal
Opis
+
+
Dodanie dwóch wartoœci
-
-
Odjêcie jednej wartoœcod drugiej
/
/ lub div
Podzielenie jednej wartoœcprzez drug¹
*
*
Pomno¿enie jednej wartoœcprzez drug¹ (ma tak¿e inne znaczenie, ale o tym póŸniej)
%
mod
Reszta z dzielenia dwóch liczb
++
brak
Zwiêkszenie o 1 (wystêpuj¹ tu dwa ró¿ne przypadkomówione poni¿ej)
--
brak
Zmniejszenie o 1 (tak¿e wystêpuj¹ tu dwa ró¿ne przypadki)
<<
shl
Przesuniêcie bitowe w lewo (omówimy je szczegó³owo poni¿ej)
>> 
shr
Przesuniêcie bitowe w prawo (omówimy je szczegó³owo poni¿ej)




4.1. Mój pierwszy program 


Gwolœcis³oœcpierwszy program mamy ju¿ za sob¹ (zosta³ on przedstawiony we "Wprowadzeniu do jêzyka C"), ale wtedy nic on nie robi³. Teraz napiszemy pierwszy program, który wykonuje jakaœ operacjê. Zanim jednak przejdziemy do napisania (co najwa¿niejsze przeanalizowania) tego programu muszê wspomnieæ jeszcze o jednej rzeczy, a mianowicie o komentarzach. Komentarz jest tekstem wpisanym do kodu programu, który jest jednak pomijany przy jego analizie przez kompilator. Jak sama nazwa wskazuje, s³u¿y on do skomentowania danego fragmentu kodu tak, aby po powrocie po miesi¹cu do kodu programu wiedzieæ jak to naprawdê dzia³a. W jêzyku C komentarzem jest wszystko, co znajduje miêdzy znakam/* */ . Dla przypomnienia - w Pascalu komentarz by³ zawarty miêdzy { } lub {* *) . Trzeba tak¿e wspomnieæ o drugim typie komentarza, a mianowicie // . W tym przypadku komentarzem jest wszystko od tych znaczków, a¿ do koñca linii. Co prawda komentarz tego typu zosta³ dopiero wprowadzony w C++, ale wiêkszoœæ kompilatorów pozwala na jego u¿ycie tak¿e dla programów pisanych w C. Ja tak¿e w przestawionych przyk³adach bêdê czêœciej stosowa³ komentarz tego typu, poniewa¿ uwa¿am, ¿e jest on wygodniejszy. Jeœljednak Twój kompilator go nie obs³uguje, po prostu zamieñ "// jakiœ tekst" na "/* jakiœ tekst */" program skompiluje bez ¿adnych problemów. Dobrze, mo¿emy wreszcie przejœæ do napisania programu. Oto on: 




void main(void)
{
  // ------------------------------
  // Deklaracja u¿ywanych zmiennych
  // ------------------------------
  int   a, b, c; // Deklaracja trzech zmiennych typu int (ca³kowita).
                 // Jak widaæ mo¿emy zadeklarowaæ kilka zmiennych tego samego
                 // typu w jednej linijce. Wystarczy je rozdzieliæ przecinkiem.

  float r = 5.3; // Deklaracja zmiennej typu float (rzeczywista) wraz z
                 // przypisaniem wartoœcpocz¹tkowej.


  // ---------------------
  // W³aœciwy kod programu
  // ---------------------
  a = 5; b = 3;  // Przypisujemy zmiennym a b wartoœci, odpowiednio, 5 3.
                 // Jak widaæ w jednej linijce programu mo¿na wpisaæ kilka
                 // instrukcjkoñcz¹c ka¿da przy pomocy œrednika.

  c = a + b;  // Dodanie zmiennych a  b wpisanie wyniku do zmiennej c.
              // Zmienna c jest teraz równa 8.

  c = a - b;  // Odjêcie zmiennej b od a wpisanie wyniku do zmiennej c.
              // Zmienna c jest teraz równa 2.

  c = a * b;  // Pomno¿enie zmiennej a przez b wpisanie wyniku do c.
              // Zmienna c jest teraz równa 15;

  // --- poni¿sze instrukcje s¹ omówione szczegó³owo w tekœcie kursu ---

  c++;        // Zwiêkszenie zmiennej c o 1. Teraz jest ona równa 16.
  ++c;        // Zwiêkszenie zmiennej c o 1. Teraz jest ona równa 17.

  --c;        // Zmniejszenie zmiennej c o 1. Teraz jest ona równa 16.
  c--;        // Zmniejszenie zmiennej c o 1. Teraz jest ona równa 15.

  c = a % b;  // Wpisanie do c reszty z dzielenia a przez b.
              // Zmienna c jest teraz równa 2.

  r = a / b;  // Podzielenie zmiennej a przez b wpisanie wyniku do r.
              // Zmienna r jest teraz równa 1.

  r = a;      // Przypisanie wartoœczmiennej a do zmiennej r. Teraz r jest
              // równe 5. Jak widaæ mimo ró¿nych typów (a jest ca³kowite,
              // natomiast r jest rzeczywiste) mo¿na bezproblemowo dokonaæ
              // takiego przypisania. Zmienna typu ca³kowitego jest konwertowana
              // na zmienn¹ typu rzeczywistego. Natomiast w Pascalu przy próbie
              // kompilacjczegoœ takiego zosta³by zg³oszony b³¹d.

  r = r / b;  // Podzielenie zmiennej r przez b. Teraz r jest równe 1.666667


  // ---------------------------
  // tworzymy nowy blok programu
  // ---------------------------
  {
    // --------------------------------------
    // Deklaracja u¿ywanych w bloku zmiennych
    // --------------------------------------
    int x=5; // Deklarujemy lokaln¹ dla tego bloku zmienna typu ca³kowitego.
             // Zmiennej tej nie mo¿emy wykorzystywaæ poza obrêbem tego bloku,
             // w takim przypadku kompilator zg³osb³¹d.

    int r=7; // Tutaj mamy ciekaw¹ rzecz. Deklarujemy wewn¹trz tego bloku
             // zmienna lokaln¹ o takiej samej nazwie jak zmienna wystêpuj¹ca
             // w bloku nadrzêdnym, jednak o innym typie (wczeœniej by³ to
             // float).


    // --------------------------------------
    // Kod bloku
    // --------------------------------------
    x += r;  // Dodajemy do zmiennej x wartoœæ zmiennej r. Teraz zmienna x
             // jest równa 12. Widzimy wiêc, ¿e w przypadku, gdy zmienna
             // lokalna ma tak¹ sam¹ nazwê jak zmienna wystêpuj¹ca w bloku
             // nadrzêdnym u¿ywana jest zmienna lokalna.

    x += a;  // Dodajemy do zmiennej x wartoœæ zmiennej a. Teraz zmienna x
             // jest równa 17.
             // Jak widzimy wewn¹trz tego bloku mo¿emy u¿ywaæ zmiennych
             // nale¿¹cych zarówno do tego bloku programu, jak zmiennych
             // zadeklarowanych w blokach nadrzêdnych (w tym przypadku
             // zmiennej a)
  }
}



Wpiszmy go w edytorze nazwijmy go "first.c". Teraz ju¿ mo¿emy spróbowaæ go skompilowaæ. W zale¿noœcod kompilatora robto w ró¿ny sposób, wiêc nie bêdê tego omawia³ - przeczytaj w dokumentacjod Twojego kompilatora. Mamy ju¿ wiêc nasz pierwszy program, przejdŸmy do jego analizy. 
Pierwsza linijka to definicja funkcjmain, która nie pobiera, annie zwraca ¿adnych parametrów (zosta³o to omówione w punkcie Typy danych). Nastêpnie deklarujemy zmienne, które bêdziemy u¿ywaæ. Jak widaæ na przyk³adzie, mo¿emy zadeklarowaæ od razu kilka zmiennych jeœls¹ one tego samego typu. Zmiennar jest zadeklarowana wraz z przypisaniem wartoœcpocz¹tkowej. Nastêpnych parê linijek to przyk³ady u¿ycia podstawowych operatorów. Myœlê, ¿e nie trzeba ich szczegó³owo omawiaæ, gdy¿ jest to logiczne. Jednak nastêpne cztery linijkto coœ nowego. Jak widaæ w komentarzu instrukcje c++; ++c; wydaj¹ dzia³aæ identycznie. Po co wiêc dwie instrukcje, które robi¹ to samo ? Diabe³ tkww szczegó³ach. W przedstawionym przyk³adzie ich dzia³anie jest rzeczywiœcie identyczne jednak obie ró¿ni¹ sposobem dzia³ania. Operator ++ u¿yty jako przyrostek to tzw. postinkrementacja, natomiast u¿yty jako przedrostek to tzw. preinkrementacja. Aby pokazaæ ró¿nicê w ich dzia³aniu pos³u¿ê przyk³adem.
Za³ó¿my, ¿e zmienna a zawiera wartoœæ piêæ wykonujemy tak¹ oto instrukcjê: 

c = a++; 

W takim przypadku do zmiennej c zostanie przypisana wartoœæ znajduj¹ca w zmiennej a (czylpiêæ) dopiero po tym przypisaniu zmienna a zostanie zwiêkszona o jeden. Czylw efekcie po wykonaniu tej instrukcjzmienna c bêdzie zawiera³a wartoœæ piêæ, natomiast zmienna a bêdzie równa szeœæ. 

Teraz przy za³o¿eniach takich samych jak powy¿ej wykonujemy tak¹ instrukcjê: 

c = ++a; 

W takim przypadku najpierw zmienna a zostanie zwiêkszona o jeden (czylteraz bêdzie równa szeœæ) nastêpnie ta wartoœæ bêdzie przypisana do zmiennej c . Czylw efekcie po wykonaniu tej instrukcjobie zmienne bêd¹ równe szeœæ. 

Analogicznie dzia³a operator -- tylko zamiast zwiêkszania, zmniejsza wartoœæ o jeden. 

Nastêpna linia zawiera operator % . Dziêkniemu mo¿emy uzyskaæ resztê z dzielenia ca³kowitego dwóch liczb. W tym przypadku dzielimy piêæ przez trzy, czylw wyniku otrzymujemy resztê z dzielenia równ¹ dwa. 

PrzejdŸmy do dalszej analizy programu. Znowu widzimy dziwn¹ rzecz - po wykonaniu: 

r = a / b; 

przy a równym piêæ b równym trzy otrzymujemy w wyniku jeden. Natomiast wykonanie ci¹gu instrukcji: 

r = a; r = r / b; 

powoduje, ¿e otrzymujemy wynik którego oczekiwaliœmy, czyl1.666667. 

Dlaczego tak dzieje ? Otó¿ trzeba zwróciæ uwagê na typy zmiennych, które bior¹ udzia³ w operacjdzielenia. W pierwszym przypadku dzielimy liczbê ca³kowit¹ przez liczbê ca³kowit¹. W takiej sytuacjwynik, który otrzymujemy jest równie¿ ca³kowity jest on wpisywany po konwersjdo zmiennej r. A poniewa¿ liczba ca³kowita nie posiada czêœcu³amkowej, wynik tej operacjpokazuje ile razy trzy ca³kowicie mieœcw pi¹tce, a reszta z tego dzielenia jest odrzucana. Aby zaradziæ takiej sytuacjmo¿na wykorzystaæ tzw. rzutowanie, ale o tym napiszê w dalszej czêœci. Uwaga dla znaj¹cych Pascala: operacjdzielenia odpowiada tutaj operator div z tego jêzyka. 

Natomiast w drugim przypadku nie ma takiego problemu poniewa¿ zmienna r jest typu rzeczywistego. Tak wiêc dzielimy liczbê rzeczywist¹ (która jest równa 5.0 - zwróæcie uwagê na to zero po kropce) przez trzy w efekcie otrzymujemy wynik, który jest tak¿e rzeczywisty. Dlatego w³aœnie jego czêœæ u³amkowa nie jest tracona wynik jest zgodny z oczekiwanym. Operacjdzielenia w tym przypadku odpowiada Pascalowe / . 

IdŸmy dalej... Jak widzimy deklarujemy tutaj nowy logiczny blok programu. Dla przypomnienia - blokiem jest tekst zawarty miêdzy { } . Ka¿dy blok mo¿e mieæ swoje zmienne, wiêc tutaj tak¿e je deklarujemy - zmienn¹ x typu int  zmienn¹ r tak¿e tego typu. Z oboma zmiennymwi¹¿¹ ciekawe rzeczy. Po pierwsze zmienna zadeklarowana wewn¹trz danego bloku jest dostêpna tylko wy³¹cznie dla tego bloku ( wszystkich bloków, które bêd¹ zadeklarowane wewn¹trz niego). Tak wiêc próba u¿ycia zmiennej x po znaku koñcz¹cym blok } , spowoduje, ¿e kompilator zg³osb³¹d. Po drugie zmienna r by³a tak¿e zadeklarowana w bloku nadrzêdnym ! Tak wiêc, która z nich zostanie u¿yta przy próbie dodania r do x ? OdpowiedŸ brzmnastêpuj¹co: u¿yta zostanie zmienna zadeklarowana "bli¿ej" miejsca jej u¿ycia. 

Po zadeklarowaniu zmiennych widzimy now¹ konstrukcjê: x += r; Có¿ to takiego ? Otó¿ jest to kompaktowa wersja operatora + . Programiœcto leniwy naród lubi¹ sobie upraszczaæ ¿ycie ;) 

Instrukcja a += b; odpowiada zapisowa = a + b; Którego z tych dwóch zapisów bêdziesz u¿ywa³ jest to obojêtne, oba dzia³aj¹ w identyczny sposób. Ja preferujê ten drug- mniej trzeba stukaæ w klawiaturê ;)
Analogicznie wygl¹da sytuacja w przypadku pozosta³ych przedstawionych operatorów (oprócz oczywiœcie ++ -- , gdy¿ nie mia³oby to wtedy sensu). 

Pozosta³y jeszcze do wyjaœnienia dwa operatory, które nie zosta³y u¿yte w tym przyk³adowym programie. S¹ nimbliŸniacze << >> . Operator << przesuwa wszystkie bity argumentu w lewo, natomiast >> przesuwa je w prawo. Byæ mo¿e nie wiesz nic o systemie dwójkowym nie rozumiesz co to tak naprawdê znaczy, ale nie martw siê. Jedyne co musisz zapamiêtaæ, to fakt, ¿e przesuniêciu liczby w lewo o jeden bit odpowiada pomno¿enie jej przez dwa, natomiast przesuniêcie w prawo podzieleniu jej przez dwa (ca³kowicie). Poni¿ej poda³em kilka przyk³adów: 

a = a << 1; // pomno¿enie zmiennej a przez 2^1, czyl2
a = a << 2; // pomno¿enie zmiennej a przez 2^2, czyl4 
a = a << 3; // pomno¿enie zmiennej a przez 2^3, czyl8

a = a >> 1; // podzielenie zmiennej a przez 2^1, czyl2
a = a >> 2; // podzielenie zmiennej a przez 2^2, czyl4
Móg³byœ jeszcze zapytaæ - po co stosowaæ przesuniêcia bitowe, skoro mogê u¿yæ zwyk³ego mno¿enia lub dzielenia ? Owszem mo¿esz, z tym, ¿e przesuniêcia bitowe s¹ o wiele szybsze, dziêkczemu mo¿esz zwiêkszyæ szybkoœæ dzia³ania swojego programu. Co prawda nowoczesne kompilatory staraj¹ optymalizowaæ Twój kod poprzez zamienienie mno¿enia, czy dzielenia na odpowiednie przesuniêcia bitowe, jednak nie robi¹ tego we wszystkich przypadkach. 

Mamy wiêc ju¿ za sob¹ nasz pierwszy program. Co prawda wyników jego dzia³ania nie widaæ na ekranie, ale mia³ on tylko wyt³umaczyæ zasadê u¿ywania operatorów w jêzyku C. Nastêpny nasz program tak¿e bêdzie mia³ za zadanie zobrazowaæ pewny sposób pisania programu nic nie wyœwietli, ale zaraz po nim napiszemy program, który wyœwietlwreszcie pierwszy tekst. Mam nadziejê, ¿e po przeanalizowaniu naszego pierwszego programu wszystko sta³o dla Ciebie bardziej jasne zrozumia³e bêdziesz móg³ przejœæ dalej. Jeœlnie, no có¿, przeczytaj jeszcze raz ten punkt, jeœlto nic nie da to napisz do mnie, lub na grupê dyskusyjn¹ pl.comp.lang.c. S¹ tam ludzie, którzy Cpomog¹ (o ile zadasz w miarê konkretne pytanie). 
<BR




5. U¿ycie funkcj


Przyjrzyj poni¿szemu programow- liczy on pole powierzchnprostok¹ta o podanych d³ugoœciach boków. 




void main(void)
{
float a, b;    // deklarujemy zmienne przechowuj¹ce bokprostok¹ta
  float dlugosc; // deklarujemy zmienn¹ zawieraj¹c¹ wynik obliczeñ

  a = 5; b =10;    // przypisujemy im wartoœci
  dlugosc = a * b; // obliczamy pole prostok¹ta (tu równe 50)
}



A co jeœlchcia³byœ obliczyæ tak¿e pole prostok¹ta o innych d³ugoœciach boków ? Odpowiesz pewnie: "Nic prostszego ! Wystarczy skopiowaæ fragment tego programu zmieniæ d³ugoœcboków". Owszem, ale co jeœlchcia³byœ obliczyæ pola stu prostok¹tów ? Albo gdybyœ liczy³ coœ bardziej skomplikowanego, co nie zajê³oby tylko jednej linijki, jak w naszym przypadku, a na przyk³ad trzydzieœc? Przy u¿yciu tego sposobu program zaj¹³by trzysta linijek ! W³aœnie dlatego w jêzyku C istniej¹ funkcje, które rozwi¹zuj¹ ten problem. Jak zbudowane s¹ funkcje to ju¿ wiesz z poprzednich punktów, ale nie znasz praktycznego ich zastosowania. Poni¿szy program wykonuje t¹ sam¹ operacjê jak ostatni, jednak obliczenia pola prostok¹ta wykonywane jest w funkcji: 




float PoleProstokata(float bok1, float bok2)
{
  // w tym miejscu bok1 jest równy 5, 
  // natomiast b jest równe 10

  float wynik;

  wynik = bok1 * bok2;
  return wynik;
}

void main(void)
{
  float a, b, dlugosc;

  a = 5; b = 10;
  dlugosc = PoleProstokata(a, b);
}



Jak widzisz, program zawiera dwie funkcje - main , która jest "obowi¹zkowa" w ka¿dym programie  PoleProstok¹ta . Analizuj¹c nag³ówek funkcjPoleProstok¹ta mo¿emy zauwa¿yæ, ¿e zwraca ona wynik obliczeñ w postacliczby rzeczywistej ( float )  przyjmuje dwa parametry - bok1 bok2 . W tym przypadku oba parametry s¹ tak¿e typu float , jednak funkcja mo¿e przyjmowaæ dowoln¹ iloœæ argumentów dowolnego typu, wystarczy je wpisaæ w formie "typ_argumentu nazwa" oddzielaæ przecinkamjeden od drugiego. 
Pojawi³o nam tu tak¿e nowe s³owo kluczowe - return . Wykonuj¹c to polecenie program powraca z funkcjdo miejsca jej wywo³ania zwracaj¹c wartoœæ podanego argumentu (który jest takiego typu, jak to okreœlono w nag³ówku funkcji). W naszym przypadku po tym poleceniu wystêpuje nazwa zmiennej wynik , tak wiêc wartoœæ zwracana przez t¹ funkcjê jest równa wartoœctej zmiennej, która z kolejest obliczana linijkê wy¿ej (iloczyn dwóch podanych argumentów). Zacznijmy jednak analizê programu od miejsca, w którym on rozpoczyna, czylod funkcjmain (pamiêtaj, ¿e jest to zawsze pierwsza funkcja wywo³ywana po uruchomieniu programu). 
Na pocz¹tku mamy znane ju¿ rzeczy - deklaracjê trzech zmiennych przypisanie wartoœci. Ostatnia linijka jest jednak nowoœci¹, do zmiennej d³ugoœæ jest coœ przypisywane. No w³aœnie, co ? Otó¿ jest to wartoœæ zwrócona przez wywo³an¹ funkcjê. Jako parametry dla tej funkcjprzekazujemy nasze zmienne a b . Jest to tzw. przekazanie przez wartoœæ, co znaczy, ¿e nie przekazujemy samych zmiennych, a tylko wartoœci, które one zawieraj¹. Wartoœcte s¹ po prostu kopiowane do parametrów bok1 bok2 nawet jeœlw ciele funkcjzmienimy ich wartoœcto zmianie ulegn¹ tylko te lokalne kopie, natomiast po powrocie do funkcjmain zmienne a b bêd¹ mia³y star¹ wartoœæ.
Po wywo³aniu funkcjPoleProstokata przenosimy do cia³a tej funkcji. W tym momencie pierwszy parametr funkcjo nazwie bok1 jest równy wartoœczmiennej a (czylpiêæ), natomiast drugo nazwie bok2 jest równy wartoœczmiennej b (czyldziesiêæ). Pierwsz¹ rzecz¹ jest deklaracja zmiennej wynik - to ju¿ znamy. Nastêpnie, w wyniku pomno¿enia zmiennej bok1 przez bok2 , do zmiennej wynik wpisana jest wartoœæ piêtnaœcie. W³aœnie t¹ wartoœæ zwracamy przy pomocy return do miejsca, w którym funkcja PoleProstokata zosta³a wywo³ana w³aœnie t¹ wartoœæ bêdzie zawiera³a zmienna d³ugosc po wykonaniu ostatniej linijkprogramu.
Mam nadziejê, ¿e zrozumia³eœ rzeczy poruszone w tym punkcie, gdy¿ funkcje to podstawa jêzyka C. Na zakoñczenie jednak wspomnê o jeszcze jednej wa¿nej rzeczy dotycz¹cej funkcji, ¿ebyœ móg³ bezboleœnie zrozumieæ nastêpny punkt. Za³ó¿my, ¿e nasz ostatnprogram zapiszemy w trochê inny sposób, tzn. najpierw zapiszemy funkcjê main , a dopiero pod ni¹ funkcjê PoleProstokata . Czylwygl¹da³oby to nastêpuj¹co: 




void main(void)
{
  float a, b, dlugosc;

  a = 5; b = 10;
  dlugosc = PoleProstokata(a, b);
}

float PoleProstokata(float bok1, float bok2)
{
  // w tym miejscu bok1 jest równy 5, 
  // natomiast b jest równe 10

  float wynik;

  wynik = bok1 * bok2;
  return wynik;
}



Jak myœlisz, czy takprogram skompiluje bez ¿adnego problemu ? Odpowiesz zapewne: "Oczywiœcie,  kolejnoœæ zapisu funkcjmia³aby wp³ywaæ na jego poprawnoœæ ?". Masz racjê, jednak tylko czêœciowo. W zale¿noœcod typu u¿ywanego przez Ciebie kompilatora, próba kompilacjtego programu albo zakoñczy zupe³nym niepowodzeniem, albo zostan¹ wyœwietlone ostrze¿enia. Dlaczego ? PodejdŸmy do zagadnienia od strony tego, w jaksposób dzia³a kompilator. Otó¿ analizuje on program, linijka po linijce, sprawdzaj¹c czy jest on poprawny. Tak wiêc sprawdza on pierwsze piêæ linijek programu, a¿ dochodzdo linii, w której mamy wywo³anie funkcjPoleProstokata . I tutaj wyœwietla b³¹d poniewa¿ nie wie co ta nazwa oznacza - annie jest to ¿adne ze s³ów kluczowych jêzyka C, annie jest to te¿ wczeœniej zadeklarowana zmienna. Sposób zapisu co prawda sugeruje, ¿e jest to jakaœ funkcja, ale sk¹d ma on wiedzieæ jakie parametry powinna ona przyjmowaæ ? Zapytasz zapewne: "Jak to nie wie ? Przecie¿ parê linijek ni¿ej jest ta funkcja zdefiniowana !". W³aœnie - parê linijek ni¿ej. A poniewa¿ kompilator analizuje poprawnoœæ programu zaczynaj¹c od jego pocz¹tku to nie wie, ¿e definicja tej funkcjznajduje gdzieœ ni¿ej (albo zupe³nie w innym pliku). Aby zaradziæ tej sytuacjstosuje w jêzyku C tzw. prototypy. Jest to po prostu informacja dla kompilatora, ¿e gdzieœ ni¿ej znajdzie funkcjê o podanej nazwie  okreœlonych parametrach. W naszym przypadku chcemy powiadomiæ kompilator o funkcjPoleProstokata . Wystarczy, ¿e dodany na samym pocz¹tku tak¹ oto linijkê: 

float PoleProstokata(float bok1, float bok2); 

Zauwa¿, ¿e jest to dok³adna kopia nag³ówka naszej funkcjzakoñczona œrednikiem. Teraz kompilator sprawdzaj¹c nasz program w pierwszej linijce znajdzie informacjê o tym, ¿e w przypadku napotkania nazwy PoleProstokata jest to funkcja, która przyjmuje dwa parametry typu float zwraca tak¿e float . 




6. Preprocesor po raz pierwszy 


W poprzednim punkcie obieca³em, ¿e napiszemy teraz nasz pierwszy program wyœwietlaj¹cy tekst na ekranie. Zastanówmy co nam bêdzie potrzebne do realizacjtego zadania ? Poniewa¿ program w jêzyku C zbudowany jest z funkcjto potrzebujemy oczywiœcie odpowiedniej funkcji, która zadanie to wykona. Funkcja taka nazywa printf . Jak ka¿e tradycja, pierwszy program powinien wyœwietlaæ napis "Hello world !", nasz nie bêdzie wyj¹tkiem: 

void main(void)
{
  printf("Hello world !");
}
Spróbuj zapisaæ ten program pod nazw¹ hello.c skompilowaæ. Zapewne kompilator zg³osi³ znany ju¿ Cb³¹d. Zapewne ju¿ domyœlasz . Wystêpuje tu taka sama sytuacja jak w naszym ostatnim programie. Kompilator nie wie co symbolizuje nazwa printf . Czego brakuje ? Oczywiœcie prototypu tej funkcj! Zanim jednak przejdziesz do wyszukania jej prototypu wpisania go na pocz¹tku programu przedstawiê Cdyrektywê #include . Pomyœl, funkcjpodobnych do printf s¹ setki, jeœlchcia³byœ u¿yæ ich w swoim programie musia³byœ wczeœniej wpisaæ prototyp ka¿dej z nich - jaka to strata czasu ! Dlatego producent Twojego kompilatora zrobi³ to za Ciebie - wpisa³ wszystkie prototypy funkcjdo plików z rozszerzeniem .h (od header - nag³ówek), które dostarczy³ razem z kompilatorem. Jednak nie bój siê, nie musisz tak¿e pracowicie u¿ywaæ kombinacj"kopiuj wklej" Twojego edytora - standard jêzyka C udostêpnia wspomnian¹ ju¿ wczeœniej dyrektywê #include , która pozwala zautomatyzowaæ t¹ operacjê. Jej u¿ycie wygl¹da tak, ¿e na pocz¹tku programu nale¿y wpisaæ: 
#include <stdio.h>
W nawiasach nale¿y podaæ nazwê pliku, który kompilator ma sobie do³¹czyæ podczas kompilacjprogramu. W naszym przypadku jest to stdio.h (skrót od standard input/output - standardowe wejœcie/wyjœcie), w którym to w³aœnie pliku znajduje prototyp funkcj"printf". Zauwa¿ tak¿e, ¿e linijka ta nie jest zakoñczona œrednikiem. Dodaj teraz podan¹ liniê do programu, skompiluj go uruchom. Pe³en sukces, na ekranie pojawi³ napis !
Na zakoñczenie omawiania tej dyrektywy mam dla Ciebie jeszcze jedn¹ uwagê odnoœnie fizycznej lokalizacjpliku nag³ówkowego. Sk¹d kompilator ma wiedzieæ, na którym dysku w którym katalogu znajduje ten plik ? Otó¿ ka¿dy kompilator ma z góry okreœlony katalog, w którym pliknag³ówkowe znajduj¹. Na ogó³ jest plikte znajduj¹ w katalogu o nazwie include , który z koleznajduje w g³ównym katalogu kompilatora. Jeœlnazwê pliku zawrzesz, tak jak jest przedstawione powy¿ej, wewn¹trz nawiasów to w³aœnie w tym katalogu kompilator bêdzie poszukiwa³ podanego pliku. Jeœlgo nie znajdzie to wyœwietlb³¹d. Istnieje tak¿e inny sposób u¿ycia tej dyrektywy, a mianowicie nazwê pliku podaje wewn¹trz cudzys³owia, czylnp. tak: 
#include "mojplik.h"
Jeœlnazwê pliku okreœlisz w ten sposób to kompilator bêdzie tego pliku szuka³ w aktualnie wybranym katalogu. 

W punkcie tym omówimy jeszcze jedno z zastosowañ innej dyrektywy, a mianowicie "#define". Pozosta³e dyrektywy zostan¹ omówione w dalszej czêœckursu (w punkcie "Preprocesor po raz drugi"). 

Dziêkdyrektywie #define mo¿na zast¹piæ czêsto u¿ywany ci¹g znaków za pomoc¹ identyfikatora. Poniewa¿ doœæ ciê¿ko jest wyt³umaczyæ sens takiego postêpowania, napiszemy program, który to zilustruje.
Za³ó¿my, ¿e chcesz napisaæ program licz¹cy pole powierzchn obwód ko³a o podanym promieniu. Do obu tych operacjbêdziesz potrzebowa³ liczby PI . Czyldwa razy u¿yjesz w swoim programie sekwencjznaków 3.1415. Bêdzie to wygl¹da³o tak: 




#include &ltstdio.h>

float ObliczPole(float promien);
float ObliczObwod(float promien);

void main(void)
{
  float pole, obwod;

  pole = ObliczPole(5);
  obwod = ObliczObwod(5);
}

float ObliczPole(float promien) 
{
  // wzór na pole to PI*R^2
  return (3.1415 * promien * promien);
}

float ObliczObwod(float promien)
{
  // wzór na obwód to 2*PI*R
  return (2 * 3.1415 * promien);
}



Pomyœl teraz, czy nie by³oby wygodniej, gdybyœ zamiast ka¿dowego wpisywania wartoœcodpowiadaj¹cej liczbie PI , móg³ wpisaæ po prostu PI ? Jeœlmyœlisz, ¿e to ¿aden problem to mam dla Ciebie jeszcze jedno pytanie. A co by³oby, gdybyœ nagle zapragn¹³ zwiêkszyæ precyzjê obliczeñ do okreœlenia liczby PI zamiast czterech, chcia³byœ zastosowaæ piêæ liczb po przecinku ? Musia³byœ w takim przypadku pracowicie przeszukiwaæ kod programu zamieniæ wszelkie wyst¹pienia ci¹gu "3.1415" na "3.14159". Przy du¿ym programie o pomy³kê nietrudno. Wszystkie te problemy mo¿na rozwi¹zaæ w³aœnie przy pomocy dyrektywy #define . Nasz program z zastosowaniem tej dyrektywy wygl¹da³by nastêpuj¹co: 




#include &ltstdio.h>

#define PI 3.1415

float ObliczPole(float promien);
float ObliczObwod(float promien);

void main(void)
{
  float pole, obwod;

  pole = ObliczPole(5);
  obwod = ObliczObwod(5);
}

float ObliczPole(float promien)
{
  // wzór na pole to PI*R^2
  return (PI * promien * promien);
}

float ObliczObwod(float promien)
{
  // wzór na obwód to 2*PI*R
  return (2 * PI * promien);
}




W trzeciej linijce mamy deklaracjê naszego symbolu o nazwie PI (zauwa¿, ¿e wyra¿enie to nie jest zakoñczone œrednikiem). Teraz kompilator ka¿de wyst¹pienie takiego tekstu w kodzie programu zast¹ptekstem "3.1415". Jeœlteraz chcielibyœmy zwiêkszyæ precyzjê obliczeñ, wystarczy, ¿e zmienimy tylko t¹ w³aœnie linijkê, a ca³y program bêdzie ju¿ u¿ywa³ tej nowej wartoœci. Prawda, ¿e wygodne ? 




7. Printf wyœwietlanie danych 


W poprzednim punkcie napisaliœmy program wyœwietlaj¹cy na ekranie tekst. Dla przypomnienia - skorzystaliœmy z funkcj"printf". Jednak co to za program, który wyœwietla z góry ustalone teksty nie ma mo¿liwoœczaprezentowania wyników przeprowadzonych operacj? W tym w³aœnie punkcie zaprzêgniemy wspomnian¹ funkcjê do takiej w³aœnie pracy. Jak zwykle pos³u¿ymy przyk³adowym programem. 




#include &ltstdio.h>

void main(void)
{
  float        f = 0.521;
  int          = -123;
  unsigned int u = 24;
  char         c = 'A';

  printf("Zmienna f = %f, natomiast zmienna jest rowna %d.\n", f, i);
  printf("Zmienna c = %c, a zmienna u jest rowna %u.\n", c, u);
  printf("Zmienna u w zapisie szestnastkowym jest rowna %x, \n", u);
  printf("natomiast w zapisie osemkowym jest rowna %o.", u);
}




Jak widzimy funkcja "printf" mo¿e tak¿e wyœwietlaæ wartoœczmiennych. Ogólny jej zapis wygl¹da tak: 

printf(ciag_formatuj¹cy, lista parametrów); 

Ci¹g formatuj¹cy jest zwyk³ym ci¹giem znaków do wyœwietlenia na ekranie. Jednak niektóre znakmaj¹ funkcjê specjaln¹ nie zostan¹ one po prostu wyœwietlone. Takim w³aœnie znakiem jest znak % . Gdy funkcja printf go napotka to wie, ¿e po nim wyst¹pokreœlenie rodzaju argumentu formatu jego wyœwietlenia na ekranie. Ogólnie wygl¹da to tak: 

% [flagi] [szerokoœæ] [precyzja] [modyfiktor wielkoœci] typ_parametru 

Tylko "typ_parametru" muswyst¹piæ po znaku % , natomiast parametry podane w nawiasach kwadratowym s¹ opcjonalne mo¿e ich w ogóle nie byæ (tak jest w przedstawionym przyk³adzie). Poni¿ej poda³em najczêœciej stosowane typy parametrów: 

%d
zmienna typu int (ze znakiem)
%u
zmienna typu int (bez znaku)
%c
zmienna typu char (litera)
%f
zmienna typu float (rzeczywista)
%x
zmienna typu int (bez znaku) wyœwietlana w postacszesnastkowej
%o
zmienna typu int (bez znaku) wyœwietlana w postacósemkowej
%s
ci¹g znaków (zostanie omówiony póŸniej)
%p
wskaŸnik (zostanie omówiony póŸniej)

Nie przera¿aj jeszcze, po przeanalizowaniu zasady dzia³ania funkcjprintf wszystko stanie jasne. Zrobimy to na podstawie pierwszej linijkz t¹ funkcj¹ w naszym programie, czyli: 

printf("Zmienna f = %f, natomiast zmienna jest rowna %d.\n", f, i); 

Po wywo³aniu funkcja printf sprawdza znak po znaku ci¹g formatuj¹cy. Ci¹g ten rozpoczyna od "Zmienna f = ". Poniewa¿ na razie nie wyst¹pi³ znak % wszystkie te znakzostan¹ po prostu wyœwietlone na ekranie. Nastêpnie napotyka na znak % , którego jednak ju¿ nie wyœwietla, ale sprawdza co stoza nim. Okazuje siê, ¿e jest to literka "f", czylrazem otrzymuje %f , która to kombinacja oznacza, ¿e w tym miejscu powinna wyœwietliæ liczbê typu rzeczywistego (patrz tabelka powy¿ej). Bierze wiêc pierwszy argument (który jest wypisany po przecinku zaraz za znakiem cudzys³owia koñcz¹cego ci¹g formatuj¹cy), którym w naszym przypadku jest zmienna f wyœwietla jego wartoœæ na ekranie. Nastêpnie przechodzdo dalszego sprawdzania ci¹gu formatuj¹cego. Wyœwietla ci¹g ", natomiast zmienna jest rowna ", poniewa¿ tak¿e nie wystêpuje w nim ¿aden znak kontrolny dochodzdo miejsca, w którym mamy drugznak % . Tym razem typem parametru jest "d", czyljest to informacja, ¿e ma wyœwietliæ liczbê ca³kowit¹ (ze znakiem). Tak wiêc funkcja printf pobiera drugargument, którym w naszym przypadku jest zmienna i, a nastêpnie wyœwietla jej zawartoœæ na ekranie. Po tym, jak ju¿ to zrobwraca do sprawdzania ci¹gu. Tym razem natyka na ".", któr¹ to wyœwietla pobiera nastêpny znak, którym jest \ . Jest to drugi, po % , znak kontrolny. Ci¹g \n daje informacjê dla printf , ¿e w tym miejscu powinna ona przejœæ do nastêpnej liniekranu. Innymczêsto u¿ywanyms¹: 

\t
tabulacja
\r
powrót karetk(kursor przesuwa do pocz¹tku linii)
\b
backspace (cofniêcie o jeden znak)
\a
bell (krótksygna³ dŸwiêkowy)
\"
znak cudzys³owia (zauwa¿, ¿e jakbyœ po prostu go wpisa³ to kompilator potraktowa³by to jako zakoñczenie ci¹gu formatuj¹cego)

Czylw efekcie, po wykonaniu tej funkcjna ekranie pojawsiê: 

"Zmienna f = 0.521000, natomiast zmienna jest rowna -123." 

Jak widzimy, wartoœæ zmiennej f jest wyœwietlona z dok³adnoœci¹ do szeœciu miejsc po przecinku. Jednak nas mog¹ interesowaæ na przyk³ad jedynie dwa miejsca po przecinku, reszty nie potrzebujemy. Wtedy nale¿y u¿yæ opcjonalnych parametrów, które mog¹ wyst¹piæ po znaku % . Dla przypomnienia ogólny zapis wygl¹da tak: 

% [flagi] [szerokoœæ] [precyzja] [modyfiktor wielkoœci] typ_parametru 

Zaczniemy od omówienia flag: 
-
wyrównuje liczbê do lewej (normalnie by³aby wyrównana do prawej)
+
liczba zawsze zaczyna od znaku "+" (dla dodatnich) lub "-" (dla ujemnych), normalnie znak jest wyœwietlany tylko dla liczb ujemnych

Teraz parametr szerokoœæ: 
n
gdzie n jest liczb¹ okreœlaj¹c¹ ile znaków zostanie wyœwietlonych. Jeœln jest wiêksze od szerokoœcliczby to zostanie ona uzupe³niona spacjami. Jeœljest mniejsze to liczba nie zostanie uciêta.
0n
gdzie n jest liczb¹ okreœlaj¹c¹ ile znaków zostanie wyœwietlonych. Jeœln jest wiêksze od szerokoœcliczby to zostanie ona uzupe³niona zerami. Jeœljest mniejsze to liczba nie zostanie uciêta.

Teraz parametr precyzja: 
Parametr ten zawsze zaczyna od kropki, a nastêpnie podajemy iloœæ liczb do wyœwietlenia po przecinku (tak jak to by³o przy szerokoœci. 

Pozosta³ jeszcze jeden parametr, a mianowicie modyfikator wielkoœci: 
l
okreœla, ¿e parametr jest typu long (np. long int to %ld)
h
okreœla, ¿e parametr jest typu short (np. short int to %hd) 


Wszystko zosta³o ju¿ omówione, na zakoñczenie podam jeszcze przyk³ady u¿ycia. Wszystkie bêd¹ pokazywa³y to, co zostanie wyœwietlone na ekranie, przy za³o¿eniu, ¿e zmienne maj¹ wartoœctakie jak w naszym przyk³adowym programie. 
"[%6.3f]"
wyœwietl"[ 0.521]". Pamiêtaj, ¿e liczba szeœæ oznacza szerokoœæ ca³ej liczby, a nie tylko czêœcprzed przecinkiem. Poniewa¿ szerokoœæ liczby jest równa piêæ, to zosta³a dodana jedna spacja _przed_ liczb¹. 
"[%-6.3f]"
wyœwietl"[0.521 ]". Jak wy¿ej, tylko spacja zosta³a dodana _po_ liczbie (wyrównanie do lewej). 
"[%06.3f]"
wyœwietl"[00.521]". Czylzamiast spacji, zosta³o dodane zero.
"[%+6.3f]"
wyœwietl"[+0.521]". Oczywiœcie dla f równego -0.521 wyœwietlznak minus, nie plus. 





8. Operacje logiczne 


O ile w przypadku operacjartymetycznych wynikiem mog³a byæ dowolna liczba (oczywiœcie z okreœlonego zakresu), to wynikiem operacjlogicznej jest jeden z dwóch mo¿liwych stanów - prawda lub fa³sz . W jêzyku C za fa³sz uznaje liczbê zero, natomiast wszystkie pozosta³e s¹ uznawane za prawdê . Wynikiem takiego traktowania stanów logicznych jest mo¿liwoœæ u¿ywania kompaktowych wersjporównañ logicznych, co zobaczymy w nastêpnej czêœctego punktu. 



8.1. Porównania 


W tym podpunkcie przedstawiê je tylko, natomiast przyk³ady ich wykorzystania zostan¹ zaprezentowane w nastêpnym podpunkcie. W jêzyku C mamy nastêpuj¹ce operatory porównania: 

C
Pascal
Opis
>
>
wiêksze ni¿
<
<
mniejsze ni¿
>=
>=
wiêksze lub równe
<=
<=
mniejsze lub równe
==
=
równe (zwróæ uwagê na podwójny znak równoœci)
!=
<>
nie równe



8.2. Instrukcja if 


Instrukcja ta jest istotnym elementem ka¿dego programu, poniewa¿ pozwala ona na modyfikacjê sposobu, w jakdzia³a program w zale¿noœcod wartoœcdanych. W jêzyku C, podobnie jak w Pascalu, ma ona nastêpuj¹c¹ sk³adniê: 

if(wyra¿enie) wyra¿enie1 else wyra¿enie2 

Jeœlwyra¿enie w nawiasie ma wartoœæ logiczn¹ prawda to zostanie wykonane wyra¿enie1, w przeciwnym wypadku zostanie wykonane wyra¿enie2. Przyk³adowo: 

if( a > 10 ) printf("Zmienna a jest wiêksza od dziesiêciu !"); else printf("Zmienna a jest mniejsza lub równa dziesiêæ !"); 

Zauwa¿, ¿e zarówno wyra¿enie po if , jak wyra¿enie po else jest zakoñczone œrednikiem. Uwagê t¹ kierujê szczególnie do osób znaj¹cych Pascala, w którym œrednik stawia dopiero na samym koñcu. Oczywiœcie, tak jak w Pascalu, czêœc"else" mo¿esz w ogóle nie u¿ywaæ, jeœlnie jest Cto akurat potrzebne. Czylmo¿esz napisaæ tak: 

if( a > 10 ) printf("Zmienna a jest wiêksza od dziesiêciu !"); 

Jeœlchcesz wykonaæ kilka instrukcjjeœlspe³niony jest pewien warunek to musisz je zawrzeæ w bloku ograniczonym znakam{ } . Czylwygl¹da³oby to nastêpuj¹co: 

if( a > 10 ) {
  printf("Zmienna a jest wieksza od dziesiêciu !\n");
  printf("Jest bowiem równa %d.", a);
} else {
  printf("Zmienna a jest mniejsza lub równa dziesiêæ !\n");
  if(a != 5) printf("Jednak nie jest równa pieæ !");
}
Oczywiœcie to, jak sformatujesz ten tekst (np. mo¿esz znak rozpoczynaj¹cy blok wpisañ w nowej linii) zale¿y tylko od Ciebie. Ja jednak preferujê taksposób, wed³ug mnie jest to bardziej czytelne. 
Pozosta³a do omówienia jeszcze jedna rzecz dotycz¹ca instrukcjif , a zwi¹zana z traktowaniem przez jêzyk C wartoœclogicznych. Zamiast: 

if ( a != 0 ) printf("a jest rozne od zera"); 

mo¿emy napisaæ: 

if( a ) printf("a jest rozne od zera"); 

bêdzie to dzia³a³o w identyczny sposób. Jak myœlisz  ? Jeœlprzeczyta³eœ uwa¿nie wstêp do operacjlogicznych to nie powinieneœ mieæ wiêkszych problemów z odpowiedzi¹ na to pytanie. W pierwszym przypadku mamy do czynienia z porównaniem wartoœczmiennej a do zera. Przyk³adowo, jeœlzmienna a jest równa dziesiêæ to warunek "a != 0" zwrócprawdê do instrukcjif zostanie wyœwietlony na ekranie tekst. Natomiast co z drugim przypadkiem ? Nie mamy tu do czynienia z ¿adnym porównaniem, do instrukcjif jest od razu przekazywana wartoœæ zmiennej a, czylw naszym przypadku dziesiêæ. Zauwa¿, nie prawda , nie fa³sz , ale liczba dziesiêæ ! I co stanie teraz ? Po prostu na ekranie pojawtekst. Pamiêtasz jak jêzyk C traktuje wartoœclogiczne ? Stanowfa³sz odpowiada liczba zero, natomiast stanowprawda ka¿da inna wartoœæ. Czyltak¿e liczba dziesiêæ ! Tak wiêc liczba ta zostanie potraktowana jako stan prawda w wyniku tego zostanie wykonana odpowiednia instrukcja (blok instrukcji) - w naszym przypadku zostanie wywo³ana funkcja printf .

Na zakoñczenie tego punktu zamieœci³em jeszcze przyk³ad czêsto pope³nianego b³êdu (który na dodatek bardzo trudno jest zlokalizowaæ), zwi¹zanego z w³aœnie takim traktowaniem stanów logicznych przez jêzyk C: 

if( a = 0 ) printf("a jest równe zero");
else printf("a jest ró¿ne od zera"); 

Jak myœlisz, co zostanie wyœwietlone na ekranie, jeœlpowiem Ci, ¿e zmienna a jest równa zero ? Jeœlodpowiesz, ¿e bêdzie to "a jest równe zero" to niestety nie bêdziesz mia³ racji. Mo¿esz zapytaæ: "Ale  ? Przecie¿ mamy porównanie a do zera poniewa¿ a jest równe zero, to powinien wyœwietliæ pierwszy napis.". Mia³byœ racjê, jeœlnaprawdê by³oby tam porównanie. Jednak przyjrzyj uwa¿nie - tam nie ma porównania ! Porównanie w jêzyku C to podwójny znak równoœci, natomiast pojedynczy (tak jak jest w tym przypadku) oznacza przypisanie. Tak wiêc najpierw zostanie tu przypisana wartoœæ zero do zmiennej a, a nastêpnie (tak jak w poprzednim przyk³adzie) wartoœæ tej zmiennej zostanie przekazana do instrukcjif , która potraktuje j¹ jako fa³sz (bo zero w³aœnie to oznacza) w efekcie wywo³a funkcjê printf wystêpuj¹c¹ po else .



8.3. Podstawowe operacje logiczne 


W podpunkcie tym przedstawiê cztery podstawowe operacje logiczne - OR, AND, NOT XOR. Jeœlwiesz na jakiej zasadzie one dzia³aj¹ to mo¿esz przejœæ do nastêpnego podpunktu. Zero w tabelodpowiada stanowfa³sz , natomiast jedynka odpowiada stanowprawda .

Operacja OR (lub)
 Wejœcie
Wyjœcie
0
0
0
1
0
1
0
1
1
1
1
1

Wynikiem operacjOR jest zero, gdy oba argumenty s¹ równe zero, lub jedynka w przeciwnym wypadku. 


Operacja AND (i)
 Wejœcie
Wyjœcie
0
0
0
1
0
0
0
1
0
1
1
1

Wynikiem operacjAND jest jedynka, gdy oba argumenty s¹ równe jeden, lub zero w przeciwnym wypadku. 


Operacja XOR
 Wejœcie
Wyjœcie
0
0
0
1
0
1
0
1
1
1
1
0

Wynikiem operacjXOR jest jedynka, gdy tylko jeden z argumentów jest równy jeden, lub zero w przeciwnym wypadku. 


Operacja NOT
 Wejœcie
Wyjœcie
0
1
1
0

Wynikiem operacjNOT jest jedynka, gdy argument by³ równy zero, lub zero, gdy argument by³ równy jeden. 



8.4. Operacje logiczne w jêzyku C 


Przedstawione w poprzednim punkcie operacje maj¹ w jêzyku C dwa aspekty - logiczny arytmetyczny (operacje na bitach). Co prawda drugz nich nale¿a³oby przedstawiæ ju¿ wczeœniej, przy okazjomawiania operacjarytmetycznych, jednak zrobiê to dopiero w tym punkcie z uwagna podobieñstwo. Najpierw jednak skupmy na pierwszym aspekcie. Oto jak operacje logiczne zapisujemy w jêzyku C: 

Operacja
C
Pascal
OR
||
or
AND
&&
and
NOT
!
not

Poniewa¿ o wiele ³atwiej jest uczyæ na przyk³adach, podam teraz program, który zilustruje wykorzystanie poznanych operacjlogicznych. 




#include &ltstdio.h>

void main(void)
{
  int a = 17;

  // przyk³ad u¿ycia operacjlogicznej OR
  if( (a  10) ) {
    printf("Zmienna a jest mniejsza od piêciu _lub_ wiêksza od dziesiêciu.\n\n");
  }

  // przyklad u¿ycia operacjlogicznej AND
  if( (a  10) && (a 


Poniewa¿ pocz¹tek programu nie wymaga chyba komentarza (jeœlwymaga to cofnij siê, proszê, do poprzednich punktów), analizê naszego programu zaczniemy od linijkz pierwszym wyst¹pieniem instrukcjif . 

W naszym przypadku chcemy wykonaæ jakieœ dzia³anie (wyœwietlenie tekstu na ekranie), gdy zmienna a jest mniejsza od piêciu lub te¿ wiêksza od dziesiêciu. Idealnie do tego celu nadaje operacja logiczna OR , której u¿ywa siê, gdy chcemy sprawdziæ czy chocia¿ jeden z podanych warunków jest prawdziwy . Widzimy, ¿e mamy tu dwa porównania - pierwsze (a < 5) , dla zmiennej a równej siedemnaœcie zwraca fa³sz , jednak drugie (a > 10) , zwraca prawdê (bo 17 > 10). Operacja logiczna OR dla takich parametrów zwraca prawdê (zobacz w tabelprzedstawionej powy¿ej), tak wiêc zostanie wyœwietlony na ekranie odpowiedntekst. Zapamiêtaj wiêc - jeœlchcesz sprawdziæ, czy którykolwiek z warunków jest spe³niony, u¿yj operacjOR. 

W sytuacji, gdy wykonanie dzia³ania ma zale¿eæ od spe³nienia wszystkich warunków, u¿ywamy natomiast instrukcjlogicznej AND . Pokazane jest to przy okazjnastêpnej instrukcjif . W tym wypadku chcemy wykonaæ dzia³anie tylko wtedy, gdy zmienna a jest wiêksza od dziesiêciu mniejsza od dwudziestu (czylzawiera w okreœlonym przedziale). Pierwszy warunek (a > 10) , dla zmiennej a równej siedemnaœcie zwraca prawdê , drug(a < 20) tak¿e zwraca prawdê . Patrz¹c do tabelwidzimy, ¿e w takim przypadku wynikiem operacjAND jest prawda , wiêc na ekranie zostanie wyœwietlony tekst o tym informuj¹cy. Zapamiêtaj wiêc - jeœlchcesz wykonanie dzia³ania uzale¿niæ od spe³nienia wszystkich warunków, u¿yj operacjAND. 

PrzejdŸmy teraz do omówienia ostatniej, najprostszej operacjlogicznej, a mianowicie NOT . Jest ona po prostu negacj¹ (zaprzeczeniem) danego parametru - tzn. ¿e dla parametru prawda zwrócfa³sz, natomiast dla parametru fa³sz zwrócwartoœæ prawda. Pokazuje to wyraŸnie trzecia z instrukcjif w naszym programie. Warunek (a < 10) jest sformu³owany tak, ¿e dla zmiennej a równej siedemnaœcie, zwrócfa³sz , czylnormalnie tekst nie zosta³by wyœwietlony na ekranie. Jednak w naszym przypadku wystêpuje jeszcze negacja, która "zamienia" fa³sz na prawdê w efekcie na ekranie pojawodpowiednnapis. 



8.5. Operacje na bitach 


Pozosta³o jeszcze do omówienia zastosowanie poznanych operacjlogicznych do wykonywania dzia³añ na bitach. Do zrozumienia (wykorzystania w swoich programach) podanych w tym punkcie informacjkonieczna bêdzie znajomoœæ podstaw dwójkowego systemu zapisu liczb. Jeœlnie wiesz co to takiego to sugerujê, ¿ebyœ pomin¹³ teraz ten punkt powróci³ do niego po zagl¹dniêciu do ksi¹¿kz matematyk(ja to mia³em w 7 lub 8 klasie podstawówki, teraz to chyba bêdzie w gimnazjum). Najpierw przedstawiê operatory jêzyka C stosowane do operacjna bitach: 

Operacja
C
Pascal
OR
|
or
AND
&
and
XOR
^
xor
NOT
~
not

Wszystkie przedstawione w tabeloperacje maj¹ tak¹ sam¹ zasadê dzia³ania. Pierwsze trzy operuj¹ na dwóch argumentach, natomiast ostatnia tylko na jednym. Algorytm dzia³ania tych pierwszych wygl¹da tak: 

1. Najpierw zamieniasz oba argumenty na postaæ binarn¹.
2. Teraz bierzesz zerowe bity obu argumentów wykonujesz odpowiedni¹ operacjê logiczn¹
3. To, co otrzyma³eœ zapisujesz w zerowym bicie wyniku.
4. Punkty dwa trzy wykonujesz kolejno dla pierwszego, drugiego, itd. bitu argumentu.
Natomiast algorytm dzia³ania operacjNOT jest du¿o prostszy - po prostu neguje ona wszystkie bity argumentu. Czylw efekcie tam, gdzie by³y zera, teraz bêd¹ jedynkodwrotnie. 

Byæ mo¿e nie zrozumia³eœ wszystkiego z powy¿szego opisu. Jednak nie martw - wszystko wyjaœnprzy analizie przyk³adowego programu: 




#include &ltstdio.h>

void main(void)
{
  char a=12, b=9;

  printf("%d and %d = %d\n", a, b, a & b);
  printf("%d or  %d = %d\n", a, b, a | b);
  printf("%d xor %d = %d\n", a, b, a ^ b);
  printf("not %d   = %d\n", b, ~b);
}




Ka¿de z wywo³añ funkcjprintf prezentuje inny operator. Zacznijmy od operacjAND. 

Jak widzisz wykonujemy operacjê AND na dwóch argumentach - zmiennej a równej dwanaœcie zmiennej b równej dziewiêæ. Po zapisaniu tego w postacdwójkowej wygl¹da to nastêpuj¹co: 

 1100  (12 w systemie dziesiêtnym)
 AND
 1001  (9 w systemie dziesiêtnym)
 ====
 1000  (8 w systemie dziesiêtnym)
Na podstawie algorytmu dzia³ania przedstawionego powy¿ej poka¿ê w jaksposób otrzymaliœmy w efekcie liczbê osiem. Najpierw zamieniamy obie liczby na postaæ binarn¹. Dla lepszego zobrazowania zapisa³em je jedna nad drug¹. Bierzemy teraz zerowy (ten z prawej) bit pierwszej liczby (12) - jest on równy zero. Nastêpnie bierzemy zerowy bit drugiej liczby (9) - jest on równy jeden. Wykonujemy operacjê AND na tych danych - w efekcie otrzymujemy zero (zobacz w tabeldla operacjAND), któr¹ to zapisujemy jako zerowy bit wyniku. Teraz to samo wykonujemy dla pierwszych bitów obu liczb. Tym razem oba s¹ równe zero, wiêc w wyniku tak¿e otrzymujemy zero. Nastêpnie wykonujemy operacjê dla bitów numer trzy obu liczb. Wynikiem dzia³ania dla argumentów równych jeden zero jest ponownie zero. Dokonujemy tej samej operacjdla bitów numer cztery obu liczb - w efekcie wykonania operacjAND na obu argumentach równych jeden, otrzymujemy jedynkê. Wynikiem ca³ej operacjjest wiêc liczba 1000 w systemie dwójkowych. Liczba ta w systemie dziesiêtnym jest równa osiem w³aœnie ona zostanie wyœwietlona na ekranie. 

Nastêpn¹ operacj¹ jest operacja OR . Po zapisaniu jej podobnie jak poprzednio otrzymujemy: 

 1100  (12 w systemie dziesiêtnym)
  OR
 1001  (9 w systemie dziesiêtnym)
 ====
 1101  (13 w systemie dziesiêtnym)
Algorytm dzia³ania jest identyczny jak poprzednio, tylko zamiast operacjAND wykonujemy operacjê OR. Wynikiem tej operacjjest jedynka, gdy którykolwiek z argumentów jest jedynk¹, st¹d te¿ tylko dla bitu pierwszego otrzymaliœmy zero, a reszta bitów jest równa jeden. 

Przedostatni¹ operacj¹ jest XOR : 

 1100  (12 w systemie dziesiêtnym)
 XOR
 1001  (9 w systemie dziesiêtnym)
 ====
 0101  (5 w systemie dziesiêtnym)
I znowu wykonujemy identyczne operacje, zamieniaj¹c tylko operacjê na XOR. Dla przypomnienia - wynikiem tej operacjjest jedynka, gdy tylko jeden z argumentów jest równy jeden. 

Ostatni¹ operacj¹ jest operacja NOT . Jak zapewne zauwa¿y³eœ po uruchomieniu programu, wynikiem operacjNOT 9 jest liczba minus dziesiêæ, któr¹ binarn¹ reprezentacj¹ jest 11110110. A oto jak j¹ otrzymaliœmy: 

 NOT
 00001001  (9 w systemie dziesiêtnym)
 ======== 
 11110110  (-10 w systemie dziesiêtnym)
Jest to najprostsza z operacjlogicznych - ja widaæ odwraca po prostu wszystkie bity argumentu. 




9. Instrukcje pêtl


Instrukcje pêtls³u¿¹ do wielokrotnego, uzale¿nionego od jakiegoœ warunku, wykonywania danego fragmentu kodu. Jêzyk C posiada trzy podstawowe konstrukcje pêtli. W tym punkcie zostan¹ one przedstawione wraz z przyk³adamich u¿ycia. 



9.1. Pêtla "while" 


Zaczniemy od razu od przyk³adowego programu: 




#include &ltstdio.h>

void main(void)
{
  int licznik = 10;

  printf("Poczatek petli\n");
  while(licznik  0)
  {
    printf("Zmienna licznik = %d\n", licznik);
    licznik--;
  }
  printf("Koniec petli\n");
}



Skompiluj go proszê uruchom. Na ekranie pojawdziesiêæ linitekstu o treœci: "Zmienna licznik = xx", gdzie xx symbolizuje kolejne numerkod dziesiêæ do jeden. Zapewne ju¿ domyœlasz jak dzia³a pêtla oparta na instrukcjwhile , lecz dla dope³nienia formalnoœcopiszê to pokrótce. Pêtla rozpoczyna od s³owa kluczowego while , po którym, podobnie jak w przypadku instrukcjif , podajemy warunek kontynuowania pêtli. Pêtla bêdzie wykonywana dopóty, dopókwarunek ten jest spe³niony. Nastêpnie podajemy instrukcjê, która bêdzie wykonywana w pêtli. Jeœlchcesz wykonywaæ w pêtlkilka instrukcji, musisz zawrzeæ je w bloku ograniczonym znakam{ } (podobnie jest w wszystkich konstrukcjach jêzyka C). W naszym przyk³adowym programie wykonujemy w pêtldwie instrukcje - wywo³ujemy funkcjê printf zmniejszamy zawartoœæ zmiennej licznik o jeden. Algorytm dzia³ania tego programu wygl¹da nastêpuj¹co: 

1. Wpisz wartoœæ dziesiêæ do zmiennej licznik.
2. Wyœwietl na ekranie tekst informuj¹cy o rozpoczêciu dzia³ania pêtli.
3. Napotykamy na instrukcjê "while" - sprawdza ona czy wartoœæ
   zmiennej licznik jest wiêksza od zera (na pocz¹tku programu jest,
   bo wpisaliœmy do niej dziesiêæ) jeœltak to przechodzdo linijki
   z wywo³aniem funkcj"printf", wewn¹trz bloku. Zauwa¿, ¿e gdybyœmy 
   zainicjalizowalzmienna licznik wartoœci¹ np. minus jeden, to od razu
   skoczylibyœmy do kroku numer siedem na ekranie pokaza³by napis o
   zakoñczeniu dzia³ania pêtl! Warunek przy instrukcj"while" by³by 
   bowiem od razu fa³szywy, w zwi¹zku z tym dzia³anie programu by³oby
   kontynuowane od pierwszej linijkza blokiem instrukcjdla pêtli.
   Jak zobaczysz w nastêpnym punkcie, istnieje tak¿e pêtla, która sprawdza 
   warunek na koñcu pêtlw wyniku tego wykona ona, w przeciwieñstwie
   do "while", przynajmniej jeden raz.
4. Jesteœmy teraz wewn¹trz bloku za pomoc¹ instrukcj"printf"
   wyœwietlamy informacjê o aktualnym stanie licznika.
5. Zmniejszamy wartoœæ zmiennej licznik o jeden.
6. Skaczemy do kroku numer trzy - dokonuje tam znowu sprawdzenie
   warunku w zale¿noœcod tego, czy zmienna licznik osi¹gnê³a ju¿ zero,
   czy nie, program bêdzie kontynuowa³ swe dzia³anie od kroku numer cztery,
   albo siedem.
7. Wyœwietlamy informacjê o zakoñczeniu dzia³ania pêtlprogram koñczy
   swe dzia³anie.
Jeszcze jedna uwaga dla znaj¹cych Pascala - oczywiœcie odpowiednikiem while w jêzyku C jest instrukcja Pascala o tej samej nazwie. 



9.2. Pêtla "do-while" 


Pêtla "do-while" jest bardzo podobna do poznanej w poprzednim punkcie "while". Jedyn¹ ró¿nic¹ jest fakt, ¿e o ile pêtla while mog³a w ogóle nie wykonaæ, jeœlwarunek nie by³ spe³niony, o tyle pêtla do-while wykona przynajmniej jeden raz, bo warunek sprawdzany jest dopiero na samym koñcu. A oto jak bêdzie wygl¹da³ nasz program z poprzedniego punktu przy u¿yciu nowej konstrukcji: 




#include &ltstdio.h>

void main(void)
{
  int licznik = 10;

  printf("Poczatek petli\n");
  do
  {
    printf("Zmienna licznik = %d\n", licznik);
    licznik--;
  } while(licznik  0);

  printf("Koniec petli\n");
}



Jak widzisz ró¿nica jest minimalna. Zwróæ tylko uwagê, ¿e po while tym razem stawiamy œrednik. Odpowiednikiem tej konstrukcjw Pascalu jest pêtla repeat-until . Wystêpuje tu jednak ró¿nica - pêtla repeat-until wykonuje do momentu, gdy warunek _stanie siê_ prawdziwy, natomiast do-while wykonuje _dopóki_ warunek jest prawdziwy. 



9.3. Pêtla "for" 


Najbardziej rozbudowan¹ konstrukcj¹ pêtljest pêtla "for". Ogólny jej zapis wygl¹da nastêpuj¹co: 

for(inicjalizacja; warunek; inkrementacja) 
{
  instrukcje do wykonania
}
Pêtla ta dzia³a na podstawie takiego oto algorytmu: 

1. Wykonywane s¹ instrukcje zawarte w czêœc"inicjalizacja". Jest to wykonywane
   tylko jeden raz, na samym pocz¹tku pêtli.
2. Sprawdzany jest warunek - jeœljest fa³szywy to nastêpuje skok do kroku
   numer szeœæ.
3. Wykonywane s¹ "instrukcje do wykonania".
4. Wykonywane s¹ instrukcje zawarte w czêœc"inkrementacja".
5. Nastêpuje skok do kroku numer dwa.
6. Pêtla koñczy - wykonywane s¹ instrukcje poza pêtl¹.
¯aden z podanych parametrów nie jest wymagany, tak wiêc najprostsz¹ pêtl¹ przy u¿yciu "for" jest: 

for(;;)
{
  instrukcje do wykonania
}
Tak¹ konstrukcjê nazywa czasem "forever" poniewa¿ jest to pêtla nieskoñczona (bêdzie wykonywa³a a¿ do momentu, gdy u¿ytkownik zresetuje komputer lub gdy napotka instrukcjê break lub goto, o których to powiemy póŸniej). 

Poka¿my wreszcie jak bêdzie wygl¹da³ nasz przyk³adowy program z poprzednich punktów przy u¿yciu pêtl"for": 




#include &ltstdio.h>

void main(void)
{
  int licznik;

  printf("Poczatek petli\n");

  for(licznik=10; licznik  0; licznik--)
  {
    printf("Zmienna licznik = %d\n", licznik);
  }

  printf("Koniec petli\n");
}



Jak widzisz konstrukcja ta jest ju¿ nieco inna od poznanych wczeœniej. W czêœcinicjalizacyjnej dokonujemy ustawienia zmiennej licznik na dziesiêæ. Moglibyœmy to zrobiæ tak jak poprzednio (od razu j¹ ustawiæ przy deklaracji) czêœæ t¹ zostawiæ pust¹, ale napisa³em to w ten sposób, ¿eby pokazaæ, ¿e mo¿na coœ takiego zrobiæ. Nastêpnie widzimy warunek - tu nic nowego, wygl¹da on dok³adnie tak samo jak poprzednio. Zmniejszenia licznika nie dokonujemy jednak wewn¹trz pêtli, lecz w czêœc"inkrementacja". Oczywiœcie moglibyœmy to zrobiæ wewn¹trz pêtli, a t¹ czeœæ pozostawiæ pust¹, ale zosta³o to wykonane w ten sposób, aby zaprezentowaæ sposób u¿ycia. 

Czêœc"inicjalizacja" "inkrementacja" mog¹ zawieraæ tak¿e po kilka instrukcj- oddzielamy je wtedy przecinkami. Dla zobrazowania takiej konstrukcjzamieœci³em nieco zmodyfikowan¹ wersjê poprzedniego programu - zosta³a dodana jeszcze jedna zmienna, która jest zwiêkszana z ka¿dym przejœciem pêtlo dwa: 




#include &ltstdio.h>

void main(void)
{
  int licznik, a;

  printf("Poczatek petli\n");

  for(licznik=10, a=5; licznik  0; licznik--, a+=2)
  {
    printf("Zmienna licznik = %d\n", licznik);
    printf("Zmienna a       = %d\n", a);
  }

  printf("Koniec petli\n");
}




<BR


9.4. Break, continue goto 


Czasem mo¿e zdarzyæ potrzeba pominiêcia jednego przebiegu pêtllub wczeœniejszego jej przerwania. S³u¿¹ do tego celu dwie wspomniane instrukcje. Instrukcja break jest wrêcz konieczna w przypadku zastosowania pêtlnieskoñczonej (pokazanej w poprzednim punkcie). Przyjrzyjmy nieco zmodyfikowanemu programowz poprzedniego punktu: 




#include &ltstdio.h>

void main(void)
{
  int licznik;

  printf("Poczatek petli\n");

  for(licznik=10; licznik  0; licznik--)
  {
    if(licznik == 5) continue;
    if(licznik == 2) break;
    printf("Zmienna licznik = %d\n", licznik);
  }

  printf("Koniec petli\n");
}



Jak widzimy program niewiele ró¿nod poprzedniego - zosta³y tylko dodane dwie linijkz instrukcj¹ warunkow¹ if . W przypadku, gdy zmienna licznik jest równa piêæ wykonywana jest instrukcja continue , a gdy jest równa dwa, wykonywana jest instrukcja break . Skompiluj teraz, proszê, program uruchom go. Widzisz jaka jest ró¿nica ? Z pocz¹tku program dzia³a identycznie z poprzednim - do wartoœczmiennej licznik równej szeœæ jest wyœwietlana odpowiednia linia. Jednak linijka informuj¹ca, ¿e zmienna licznik jest równa piêæ w ogóle nie zosta³a wyœwietlona - odpowiedzialna jest za to instrukcja continue . Na pocz¹tku nie jest ona wykonywana, jednak gdy zmienna licznik dojdzie do wartoœcpiêæ, zostaje ona wykonana. Powoduje to, ¿e pêtla for pomija wszystkie nastêpuj¹ce po continue instrukcje wewn¹trz pêtl(dla danego przebiegu) przechodzod razu do nastêpnej iteracji. W nastêpnych dwóch przebiegach ¿aden z warunków wystêpuj¹cych po instrukcjach if nie jest spe³niony program wyœwietla informacje, ¿e zmienna licznik jest równa, kolejno, cztery trzy. Dochodzimy teraz do momentu, gdy zmienna licznik osi¹ga wartoœæ dwa. W takim wypadku spe³niony jest warunek drugiej z instrukcjif wykonywana jest instrukcja break . Jakjest tego rezultat widzisz na ekranie - pêtla koñczy swe dzia³anie zostaje wyœwietlony komunikat o tym informuj¹cy. 

Alternatyw¹ instrukcjbreak jest instrukcja goto . Mimo, ¿e w przypadku jêzyków strukturalnych (jakim jest jêzyk C, jak równie¿ Pascal) jej stosowanie jest wrêcz têpione (szczególnie na poziomie nauczania jêzyka), to jest jednak sytuacja, gdy mo¿na j¹ zastosowaæ poniewa¿ nie istnieje ¿aden inny prosty sposób osi¹gniêcia celu. Sytuacj¹ t¹ jest wyjœcie z zagnie¿d¿onej pêtli. Od razu to zilustrujemy odpowiednim przyk³adem - za³ó¿my, ¿e mamy do czynienia z takim przypadkiem: 




#include &ltstdio.h>

void main(void)
{
  int a, b;

  printf("Poczatek petli\n");

  for(a=0; a < 4; a++)
  {
    for(b=0; b < 4; b++)
    {
      // if((a==2) && (b==1)) break;
      printf("a = %d, b = %d\n", a, b);
    }
  }
  printf("Koniec petli\n");
}



Jak widzimy mamy tu zagnie¿d¿on¹ pêtlê, tzn. jedna pêtla jest wykonywana w drugiej. W sumie otrzymamy wiêc na ekranie 4*4=16 linijek tekstu. Za³ó¿my teraz, ¿e chcielibyœmy zakoñczyæ wykonywanie obu pêtlprzy zmiennej a równej dwa zmiennej b równej jeden. Jeœlu¿ylibyœmy instrukcjbreak (tak jak to pokazano w komentarzu) to przerwalibyœmy tylko pêtlê, w której jest zwiêkszana wartoœæ zmiennej b. W efekcie na ekranie pojawi³oby siê: 

Poczatek petli
a=0, b=0
a=0, b=1
a=0, b=2
a=0, b=3
a=1, b=0
a=1, b=1
a=1, b=2
a=1, b=3
a=2, b=0
a=3, b=0
a=3, b=1
a=3, b=2
a=3, b=3
Koniec petli
Czyljak widzimy pêtla "b" rzeczywiœcie zosta³a przerwana przy a równym dwa, ale nastêpnie zosta³a ona ponownie wykonana dla a równego trzy. A my chcieliœmy zakoñczyæ obie pêtle ! Rozwi¹zaniem jest tutaj u¿ycie instrukcjgoto: 




#include &ltstdio.h>

void main(void)
{
  int a, b;

  printf("Poczatek petli\n");

  for(a=0; a < 4; a++)
  {
    for(b=0; b < 4; b++)
    {
      if((a==2) && (b==1)) goto koniec;
      printf("a = %d, b = %d\n", a, b);
    }
  }

  koniec:

  printf("Koniec petli\n");
}




W programie tym instrukcja break zosta³a zast¹piona przez goto koniec . "koniec" jest to tzw. etykieta. Zadeklarowaliœmy j¹ przed ostatni¹ instrukcj¹ programu - jest to po prostu dowolna nazwa zakoñczona dwukropkiem. W programie mo¿emy zadeklarowaæ dowoln¹ liczbê etykiet (oczywiœcie ka¿da musmieæ inn¹ nazwê). Aby przenieœæ wykonywanie programu do innego miejsca nale¿y wykonaæ instrukcjê goto podaj¹c jej nazwê etykiety, do której ma nast¹piæ skok. W naszym przypadku po wykonaniu instrukcjgoto koniec program wyœwietlinformacjê o koñcu pêtlzakoñczy swe dzia³anie. Po uruchomieniu powy¿szego programu na ekranie uzyskamy: 

Poczatek petli
a=0, b=0
a=0, b=1
a=0, b=2
a=0, b=3
a=1, b=0
a=1, b=1
a=1, b=2
a=1, b=3
a=2, b=0
Koniec petli
czyldok³adnie to, o co nam chodzi³o. 




10. Instrukcja switch 


Instrukcja switch jest odpowiednikiem pascalowej instrukcjcase . Jeœlznasz pascala to ju¿ wiesz o co chodzi, jeœ³jednak nie, to zaraz zobaczysz jak to wygl¹da w praktyce kiedy mo¿e przydaæ. Za³ó¿my, ¿e mamy takoto program: 




#include &ltstdio.h>

void main(void)
{
  int a = 5;

  if(a == 4) printf("Zmienna a jest rowna cztery.\n");
  else if((a == 5) || (a==6)) printf("Zmienna a jest równa piec lub szesc.\n");
  else printf("Zmienna a jest nie jest rowna ancztery, anpiec, anszesc.\n");
}



Jakwidzisz program na podstawie wartoœczmiennej a wypisuje na ekranie odpowiedntekst. Aby ten cel osi¹gn¹æ musieliœmy zastosowaæ sekwencjê instrukcjif . Nie wygl¹da to jednak zbyt elegancko. W³aœnie takim przypadku mo¿emy u¿yæ instrukcjê switch . A oto jak bêdzie wygl¹da³ nasz program przy jej u¿yciu: 




#include &ltstdio.h>

void main(void)
{
  int a = 5;

  switch(a) 
  {
    case 4 : printf("Zmienna a jest rowna cztery.\n");
             break;
    case 5 :
    case 6 : printf("Zmienna a jest rowna piec lub szesc.\n");
             break;
    default: printf("Zmienna a jest nie jest rowna ancztery, anpiec, anszesc.\n");
  }  
}



Wed³ug mnie jest to o wiele bardziej czytelne, czy¿ nie ?
Dobrze, napiszê wiêc coœ wiêcej o samej konstrukcji. Generalnie wygl¹da ona tak: 
 switch(wyra¿enie) 
 {
   case wartosc1: instrukcje; break;
   case wartosc2: instrukcje; break;
   .
   .
   .
   default: instrukcje;
 }
Jak widzisz zaczynamy od s³owa kluczowego switch . Zaraz po nim podajemy w nawiasie wyra¿enie, od którego wartoœcbêdzie mia³a zale¿eæ akcja, która zostanie wykonana. W naszym przyk³adowym programie chcieliœmy, ¿eby napis na ekranie by³ zale¿ny od zmiennej a, wiêc wpisaliœmy tam po prostu "a". Jednak nic nie stona przeszkodzie, aby na przyk³ad wpisaæ tam "a*3+b" (zak³adaj¹c oczywiœcie, ¿e zadeklarowaliœmy wczeœniej zmienn¹ b). Nastêpnie otwieramy blok wpisujemy po s³owie kluczowym case wartoœci, które bêd¹ porównywane z tym wyra¿eniem. Konstrukcja switch szuka pierwszej wartoœci, która jest równa wyra¿eniu podanemu w nawiasie. Jeœlj¹ znajdzie to przekazuje wykonywanie programu do tego miejsca. Nastêpnie wykonywane s¹ kolejne instrukcje, a¿ do napotkania nawiasu klamrowego koñcz¹cego blok switch , albo a¿ do napotkania instrukcjbreak. Jeœl¿adna z wartoœcpodanych po case'ach nie jest równa danemu wyra¿eniu to wykonywane s¹ instrukcje po slowie kluczowym default (jego u¿ywanie nie jest konieczne - tak wiêc, jeœlgo nie wpisze to ¿adne dzia³anie nie zostanie wykonane). W naszym przypadku zmienna a by³a równa piêæ, tak wiêc wykonywanie programu zosta³o przekazane do miejsca, w którym mamy przypadek "case 5:". Poniewa¿ nie wystêpuje po nim instrukcja break , to wykonywanie programu jest kontynuowane. W nastêpnej linijce wyœwietlany jest napis informuj¹cy o wartoœczmiennej program przechodzdo nastêpnej linii. Mamy tam s³owo kluczowe break , które koñczy konstrukcjê switch .
Gdyby zmienna a by³a równa cztery to przeszlibyœmy do linijkz "case 4:", wywo³anaby by³a funkcja printf wystêpuj¹ca dalej program napotka³by instrukcjê break , która zakoñczy³aby dzia³anie konstrukcjswitch .
Gdyby zaœ zmienna ta by³a równa dziesiêæ, to przeszlibyœmy do linijkz "default:", wyœwietlony by³by odpowiednnapis.
Na koniec jeszcze uwaga dla osób znaj¹cych pascala - oczywiœcie odpowiednikiem przedstawionej tu instrukcjjest w tym jêzyku instrukcja case. 




11. Operator "?" 


Operator ? jest bardzo u¿yteczn¹, lecz czêsto nie docenian¹ konstrukcj¹. Jak zwykle jego zastosowanie poka¿emy na przyk³adzie. Za³ózmy, ¿e mamy do czynienia z dwoma zmiennyma b chcielibyœmy wyœwietliæ na ekranie wartoœæ wiêkszej z nich. Program przy u¿yciu znanej ju¿ instrukcjif wygl¹da³by tak: 
#include <stdio.h>

void main(void)
{
  int a = 5, b = 6, c;

  if(a > b) c=a; else c=b;

  printf("Max(a,b) = %d\n", c);
}
Jak widzisz programik jest proœciutk- gdy zmienna a jest wiêksza od zmiennej b to przypisuje zmiennej c wartoœæ zmiennej a, natomiast w przeciwnym wypadku przypisuje jej wartoœæ zmiennej b. Nastêpnie na ekranie wyœwietla wartoœæ zmiennej c.
Jednak teoria o tym, ¿e programiœcto leniwe bestie potwierdza tym razem ;) Co z tego, ¿e zapis jest proœciutki, skoro mo¿na zrobiæ to jeszcze proœciej ? Do tego celu s³u¿y w³aœnie operator ? . Nasz programik przy jego u¿yciu wygl¹da³by tak: 
#include <stdio.h>

void main(void)
{
  int a = 5, b = 6, c;

  c = (a > b) ? a : b;

  printf("Max(a,b) = %d\n", c);
}
Jak widzisz instrukcja if zosta³a zamieniona na coœ, co z pocz¹tku mo¿e wydawaæ strasznie dziwnym zapisem. Jednak nie przera¿aj - wcale nie jest to takie straszne. Zauwa¿, ¿e mamy tu do czynienia z takim przypadkiem: 
 c = jakieœ_wyra¿enie; // gdzie wyra¿enie to jest operatorem "?"
Ogólna konstrukcja tego operatora wygl¹da tak: 
  (wyra¿enie_logiczne) ? wyra¿enie_gdy_prawda : wyra¿enie_gdy_fa³sz
Najpierw sprawdzane jest wyra¿enie logiczne w nawiasie, jeœljest ono prawdziwe, to obliczana jest wartoœæ wyra¿enia znajduj¹cego sie po znaku ? jest ona zwracana, natomiast w przypadku, gdy wyra¿enie logiczne by³o fa³szywe to obliczana jest wartoœæ wyra¿enia znajduj¹cego po znaku : w³aœnie ona jest zwracana. Czylw naszym przyk³adowym programie najpierw sprawdzamy, czy zmienna a jest wiêksza od zmiennej b. Poniewa¿ a jest równe piêæ, natomiast b jest równe szeœæ to wyra¿enie to jest fa³szywe obliczana jest wartoœæ wyra¿enia wystêpuj¹cego po znaku : . W naszym przypadku jest tam po prostu zmienna b, ktorej wartoœæ jest zwracana przypisana do zmiennej c. 

Zapewne powiesz: "No dobrze, ale ten zapis wcale nie jest du¿o krótszy od poprzedniego, a poza tym jest o wiele mniej czytelny". Masz racjê, jednak ca³a si³a operatora ? tkww tym, ¿e mo¿na go u¿ywaæ praktycznie w ka¿dej sytuacji. Przyk³adowo, nasz program mo¿na zapisaæ w ten sposób: 
#include <stdio.h>

void main(void)
{
  int a = 5, b = 6;

  printf("Max(a,b) = %d\n", (a>b) ? a : b);
}
Jak widzisz wartoœæ wyra¿enia jest od razu przekazywana do funkcjprintf . Czegoœ takiego przy u¿yciu instrukcjif nie da zrobiæ, bo nie zwraca ona ¿adnej wartoœci, a jedynie, w zale¿noœcod warunku, wykonuje te, lub inne instrukcje. 




12. Rzutowanie 


O rzutowaniu wspomnia³em ju¿ w punkcie Mój pierwszy program. Mieliœmy tam do czynienia z tak¹ oto sytuacj¹: 




#include &ltstdio.h>

void main(void)
{
  int a = 5, b = 3;
  float r;
  
  r = a / b;  
  printf("r = %f\n", r);
}



Jak zapewne pamiêtasz wynik tej operacjnieco Ciê zaskoczy³ - nie by³o to "1.666667", lecz po prostu "1.000000". Dzia³o tak dlatego, ¿e argumenty operacjdzielenia by³y typu ca³kowitego, a ten, jak wiesz, nie przechowuje informacjo czêœcu³amkowej. W efekcie wynik operacjtak¿e by³ ca³kowity ta w³aœnie ca³kowita wartoœæ by³a przypisana zmiennej r. Aby temu zaradziæ mo¿na wykorzystaæ tzw. rzutowanie. Jest to tymczasowa, tylko dla potrzeb obliczenia danego wyra¿enia, zmiana typu. Typ ten jednak nie zmienia fizycznie, po prostu kompilator traktuje zmienn¹ danego typu tak, jakby by³a typu, na który j¹ rzutujemy. Tak wiêc nasz program mo¿emy zapisaæ nastêpuj¹co: 




#include &ltstdio.h>

void main(void)
{
  int a = 5, b = 3;
  float r;
  
  r = (float)a / b;  
  printf("r = %f\n", r);
}



Jak widzisz program ten niewiele ró¿nod poprzedniego. Jedyn¹ ró¿nic¹ jest to, ¿e przed zmienn¹ a przy operacjdzielenia dodany zosta³ takoto ci¹g znaków: "(float)". W³aœnie ten ci¹g informuje kompilator, ¿e zmienna (lub wyra¿enie) nastêpuj¹ce za nim ma byæ traktowane tak, jakby by³o typu float . W naszym przypadku mówimy kompilatorowi, ¿eby potraktowa³ zmienn¹ a jakby by³a typu rzeczywistego (czyltak naprawdê rozszerza j¹ do postac"5.0"), a nastêpnie t¹ rzeczywist¹ liczbê podzieli³ przez zmienn¹ b, która jest typu ca³kowitego.
Podumowuj¹c, rzutowanie wykorzystujemy, aby przy operacjach przypisania do siebie ró¿nych typów poinformowaæ kompilator, ¿e wiemy, co robimy ma on traktowaæ to zgodnie z naszym ¿yczeniem. Aby dokonaæ rzutowania danej zmiennej, czy wyra¿enia na inny typ, nale¿y przed ni¹ (nim) wpisaæ w nawiasach typ, na który chcemy rzutowaæ. 




13. Definicja w³asnych typów 


Jêzyk C, poza wbudowanymtypamdanych (np. int , czy float ), umo¿liwia tak¿e definicjê w³asnych typów danych. W tym punkcie zostan¹ przedstawione ró¿ne aspekty tego tematu. 



13.1. Typ wyliczeniowy 


Typ wyliczeniowy nie jest typem danych w œcis³ym tego s³owa znaczeniu, gdy¿ jest to odpowiednik typu int . Ma on jednak ciekaw¹ cechê, a mianowicie kolejne jego elementy mo¿emy nazwaæ wedle swojego uznania. Jak zwykle prezentacjê nowych rzeczy zaczniemy od przyk³adowego programu: 




#include &ltstdio.h>

void main(void)
{
  enum {Pn, Wt, Sr, Czw, Pt, Sb=10, Nd} DzienTyg;

  DzienTyg = Pn; printf("Wartosc dla poniedzialku = %d\n", DzienTyg);
  DzienTyg = Wt; printf("Wartosc dla wtorku = %d\n", DzienTyg);
  DzienTyg = Sr; printf("Wartosc dla srody = %d\n", DzienTyg);
  DzienTyg = Czw; printf("Wartosc dla czwartku = %d\n", DzienTyg);
  DzienTyg = Pt; printf("Wartosc dla piatku = %d\n", DzienTyg);
  DzienTyg = Sb; printf("Wartosc dla soboty = %d\n", DzienTyg);
  DzienTyg = Nd; printf("Wartosc dla niedziel= %d\n", DzienTyg);
}



W programie tym chcemy operowaæ na zmiennej, która bêdzie przechowywaæ dzieñ tygodnia. Moglibyœmy po prostu zadeklarowaæ j¹ jako int przyj¹æ za³o¿enie, ¿e poniedzia³kowodpowiada wartoœæ zero, wtorkowwartoœæ jeden itd. Jednak, gdy przy dalszej rozbudowie programu chcielibyœmy przypisaæ tej zmiennej wartoœæ "Œroda" to musielibyœmy sobie przypominaæ jaka liczba jej odpowiada. Mo¿emy jednak u³atwiæ sobie to zadanie dziêkzastosowaniu enum . Ka¿dej kolejnej wartoœcmo¿emy przydzieliæ identyfikator, który ³atwiej bêdzie zapamiêtaæ. Jak widzisz w naszym programie zadeklarowaliœmy identyfikatory "Pn", "Wt", "Sr" itd. enum ju¿ sam zadba o przydzielenie im konkretnych wartoœc- tzn. "Pn" bêdzie odpowiada³o wartoœczero, "Wt" jeden itd. Jeœlz jakiegoœ powodu chcia³byœ, aby od pewnego identyfikatora nast¹pi³ przeskok ¿eby liczenie zaczyna³o od innej wartoœcto podajesz j¹ po znaku równoœci. W naszym przyk³adzie identyfikatorow"Sb" przydzieliliœmy wartoœæ dziesiêæ (pamiêtaj, ¿e kolejnym identyfikatorom bêda odpowiada³y zmienione ju¿ wartoœc- w naszym przyk³adzie niedzielbêdzie przydzielona wartoœæ jedenaœcie). Teraz zamiast pisaæ: 
DzienTyg = 2;
mo¿emy po prostu napisaæ: 
DzienTyg = Sr;
Wa¿ne jest jednak, abyœ pamiêta³, ¿e mimo faktu przypisywania zmiennej wartoœcpoprzez nadane identyfikatory, to nadal s¹ to zwyk³e liczby. 



13.2. Typedef 


Przedstawione w poprzednim podpunkcie enum mimo faktu, ¿e mamy tam wp³yw na nadawanie nazw identyfikatorom, nie deklaruje jednak nowego typu. Zmienna typu wyliczeniowego jest ci¹gle zmienn¹ typu int . Do deklaracjnowego typu danych s³u¿y instrukcja typedef . A oto przyk³ad jej u¿ycia: 




#include &ltstdio.h>

typedef float rzeczywista;

void main(void)
{
  rzeczywista a=4.5;

  printf("%f\n", a);
}



Ogólna postaæ deklaracjto wygl¹da nastêpuj¹co: 
typedef definicja_typu nazwa_nowego_typu;
W naszym przypadku przyk³ad deklaracjnowego typu danych, któremu nadaliœmy nazwê "rzeczywista", mamy w drugiej linijce programu. Okreœliliœmy tam, ¿e nowy typ bêdzie po prostu typem float tylko ze zmienion¹ nazw¹. Poniewa¿ identyfikator "rzeczywista" odpowiada od tego momentu nowemu typowdanych to mo¿emy zadeklarowaæ sobie zmienn¹ tego typu. W funkcjmain deklarujemy zmienn¹ o nazwie a. Poniewa¿ jej typ zosta³ wyprowadzony z typu float to mo¿emy u¿ywaæ jej tak, jakby by³a to zmienna typu float. W naszym programie po prostu j¹ wyœwietlamy na ekranie. 

Zastanawiasz zapewne czemu s³u¿y to polecenie, skoro mo¿emy po prostu u¿ywaæ wbudowanego typu float . Odpowiedzs¹ trzy. Po pierwsze, deklaracja ta mo¿e dotyczyæ o wiele bardziej z³o¿onego typu danych. Po drugie, dziêktemu mo¿emy w ³atwy sposób przenieœæ nasz program na inny kompilator lub system. Przypomnij sobie, ¿e na przyk³ad zmienna typu int mo¿e na jednym kompilatorze zajmowaæ cztery bajty, a na innym tylko dwa. Mo¿emy w ³atwy sposób temu zaradziæ poprzez deklaracjê naszego nowego typu o nazwie na przyk³ad "MOJINT" wszêdzie go u¿ywaæ. Teraz jeœlchcielibyœmy go przenieœc na inny kompilator to wystarczy jedynie zmieniæ deklaracjê typu gotowe ! Trzecim powodem mo¿e byæ chêæ zwiêkszenia precyzjobliczeñ. Jeœlprogram wszelkie obliczenia wykonywa³ na zmiennych typu float to w takim przypadku musielibyœmy zmieniæ wszelkie wyst¹pienia tego typu na typ double . A tak wystarczy jedynie zadeklarowaæ nowy typ, na przyk³ad "MOJFLOAT" u¿ywaæ go zamiast float , a przy koniecznoœczwiekszenia precyzjzmieniæ jedynie deklaracjê typu "MOJFLOAT" tak, ¿eby wyprowadzony by³ z typu double . 



13.3. Struktury 


W tym punkcie powiemy sobie o strukturach (odpowiednikach pascalowych rekordów), czylo z³o¿onym typie danych. Jest to typ danych tworzony przez programistê, który jest kombinacj¹ wczeœniej zdefiniowanych typów, w³¹czaj¹c w to, oprócz typów prostych, inne typy zdefiniowane przez programistê (tak¿e inne struktury). Zaczniemy, jak zwykle, od przyk³adowego programu: 




#include &ltstdio.h>

typedef struct {
  int godziny;
  int minuty;
  int sekundy;
} CZAS;

void main(void)
{
  CZAS teraz;
  int  ile_sekund;

  teraz.godziny = 23;
  teraz.minuty  = 53;
  teraz.sekundy = 21;

  printf("Teraz jest %d:%d:%d\n", teraz.godziny, teraz.minuty, teraz.sekundy);

  ile_sekund = teraz.sekundy + teraz.minuty*60 + teraz.godziny*3600;
  printf("Od poczatku dnia uplynelo %d sekund.\n", ile_sekund);
}



Analizê programu zaczniemy od miejsca definicjnowego typu danych, który tym razem nie bêdzie, tak jak ostatnio, tylko odpowiednikiem prostego typu, lecz ca³kowicie nowym, z³o¿onym typem (struktur¹). Ogólna postaæ definicjstruktury wygl¹da nastêpuj¹co: 
 typedef struct {
   typ nazwa_pola1;
   typ nazwa_pola2;
   .
   .
   .
   typ nazwa_polaN;
 } nazwa_struktury;
W naszym przypadku zdefiniowaliœmy sobie strukturê o nazwie CZAS zawieraj¹c¹ trzy pola typu int (godziny, minuty sekundy), która zosta³a zaprojektowana do przechowywania informacjo konkretnym czasie (st¹d nazwa ;) Moglibyœmy co prawda te same informacje przechowywaæ w trzech osobnych zmiennych, ale co jeœlchcielibyœmy mieæ dane o dwóch ró¿nych godzinach ? Musielibyœmy dodaæ trzy nowe zmienne, co wkrótce doprowadzi³oby do kompletnego chaosu. Struktura pozwala nam przechowywaæ potrzebne infromacje, przy czym wszystko znajduje sie w jednym miejscu - zamiast trzech, mamy tylko jedn¹ zmienn¹. PrzejdŸmy dalej - na pocz¹tku funkcjmain widzimy deklaracjê zmiennej typu CZAS o nazwie "teraz", która bêdzie przechowywaæ potrzebne nam informacje. Czylnarazie nic nowego. Natomiast w nastêpnych trzech linijkach widzimy zupe³nie now¹ kostrukcjê. Przedstawia ona w jaksposób odwo³ujemy do poszczególnych pól struktury - czyli: podajemy nazwê zmiennej (u nas nazywa ona "teraz"), potem stawiamy kropkê, a nastêpnie podajemy nazwê pola, do którego odnosimy. Poza tym, ¿e do poszczególnych pól odwo³ujemy w nowy sposób, mo¿emy z nich korzystaæ tak jakby by³aby to normalna zmienna o danym typie - czylmo¿emy przypisywaæ jej wartoœæ, czy te¿ u¿ywaæ wszelkich operatorów, co zosta³o pokazane na przyk³adzie obliczania liczby sekund, które up³ynê³y od pocz¹tku dnia. 

Strukturê mo¿na tak¿e zdeklarowaæ tak¿e w nieco inny sposób ni¿ przedstawiony wczeœniej, a mianowicie: 
 struct nazwa_struktury {
   typ nazwa_pola1;
   typ nazwa_pola2;
   .
   .
   .
   typ nazwa_polaN;
 };
Jednak ja zalecam stosowanie tego pierwszego sposobu, gdy¿ przy deklaracjzmiennej nie wystarczy napisaæ tak jak w poprzednim przypadku: 
  nazwa_struktury nazwa_zmiennej;
ale nale¿y zastosowaæ nieco d³u¿sza sk³adniê: 
 struct nazwa_struktury nazwa_zmiennej;
Poza tym faktem, oba sposoby deklaracjnie ró¿ni¹ niczym. 



13.4. Unie 


Unie "z wygl¹du" s¹ bardzo podobne do znanych Cju¿ struktur. Inny jest jednak cel ich wykorzystania. S³u¿¹ one mianowicie efektywnemu wykorzystaniu pamiêci. Ka¿de ich pole zajmuje fizycznie t¹ sam¹ komórkê pamiêci, z tego te¿ wzglêdu, w danym momencie mo¿e byæ wykorzystywane tylko jedno z ich pól. Jeœlwydaje Cto dziwne to przyjrzyj nastêpuj¹cemu przyk³adowi: 




#include &ltstdio.h>

typedef union {
 float szybkosc_w_wezlach;
 int   szybkosc_w_km;
} POJAZD;

void main(void)
{
  POJAZD samochod, statek;

  samochod.szybkosc_w_km    = 220;
  statek.szybkosc_w_wezlach = 34.5;

  printf("Max. szybkosc samochodu to %d km/h\n", samochod.szybkosc_w_km);
  printf("Max. szbkosc statku to %3.1f wezlow\n", statek.szybkosc_w_wezlach);
}




Za³o¿eniem programu jest przechowywanie informacjo maksymalnej szybkoœcdanego pojazdu. Jednak pojazdem mo¿e byæ zarówno samochód, który ma t¹ informacjê wyra¿on¹ w km/h, jak równie¿ statek, w przypadku którego wyra¿a j¹ w wêz³ach. Tak wiêc, gdybyœmy wykorzystaldo tego celu strukturê to jedno z pól  nie by³oby wykorzystywane, przez co tracilibyœmy miejsce w pamiêci. Co prawda w tym przypadku by³yby to zaledwie cztery bajty, ale gdybyœmy mieldu¿¹ tablicê takich struktur (o których powiemy póŸniej) to strata by³aby ju¿ znaczna. W takim przypadku mo¿emy wykorzystaæ uniê - zadeklarowaliœmy dwa pola, do których mo¿emy odwo³ywaæ u¿ywaj¹c ró¿nych nazw, jednak tak na prawdê zajmuj¹ one tylko tyle miejsca w pamiêci, ile zajmujê najwiêkszy element (w naszym przypadku oba pola maj¹ wielkoœæ cztery bajty, wiêc unia zajmuje w pamiêctak¿e cztery bajty). Myœlê, ¿e nie trzeba omawiaæ problemu od strony sk³dniowej - wystarczy powiedzieæ, ¿e sk³adnia jest dok³adnie taka sama jak w przypadku struktur. Jedyn¹ ró¿nic¹ jest to, ¿e zamiast s³owa kluczowego struct u¿ywamy s³owa kluczowego union . 



13.5. Pola bitowe 


Pola bitowe s¹ kolejnym odcinkiem z seri"Oszczêdzanie pamiêci". Maj¹ zastosowanie przy definicjstruktur - przy pomocy tej konstrukcjmo¿emy zadeklarowaæ pole, którego wielkoœæ bêdzie mniejsza ni¿ jeden bajt (jeden lub kilka bitów - st¹d nazwa). A oto przyk³ad: 




#include &ltstdio.h>

typedef struct {
 unsigned char  szyberdach   : 1;
 unsigned char  abs          : 1;
 unsigned char  ilosc_miejsc : 4;
} SAMOCHOD;

void main(void)
{
  SAMOCHOD ford;

  ford.szyberdach = 1;
  ford.abs = 1;
  ford.ilosc_miejsc = 2;

  printf("Ilosc miejsc : %d\n", ford.ilosc_miejsc);
  if(ford.szyberdach) printf("Posiada szyberdach.\n");
  if(ford.abs) printf("Posiada ABS.\n");
}



Program ten przechowuje wyœwietla informacje o samochodzie, a konkretnie o liczbie miejsc, o tym, czy posiada szyberdach ABS. Normalnie potrzebowalibyœmy zadeklarowaæ strukturê o trzech polach, która, przy zastosowaniu jednobajtowego typu char, zajê³aby trzy bajty w pamiêci. Dziêkzastosowaniu pól bitowych wszystkie te informacje zajmuj¹ jeden, jedyny bajt pamiêc(to, w przeciwieñstwie do unii, z mo¿liwoœci¹ odwo³ywania do wszystkich pól jednoczeœnie). Jak to mo¿liwe ? Otó¿ ograniczyliœmy zakres poszczególnych pól. Zastanówmy siê, ile potrzeba miejsca w pamiêci, aby przechowaæ informacjê o fakcie wyposa¿enia, b¹dŸ nie, samochodu w ABS ? S¹ dwa mo¿liwe stany - jest lub nie ma. Czylinnyms³owy jedynka, albo zero - wystarczy jeden bit ! To samo tyczy szyberdachu. Jeœlchodzo liczbê miejsc to w tym przypadku ograniczy³em liczbê mo¿liwych wartoœcdo 16 - po prostu przeznaczy³em na to pole cztery bity (a 2^4 = 16). W ten sposób zamiast u¿wyaæ trzech, struktura ta u¿ywa zaledwie jednego bajtu.
Od strony sk³adniowej dostêp do pól bitowych jest identyczny, jak do tych "normalnych". Jedyn¹ ró¿nic¹ jest sposób ich deklaracj- tzn. deklaruje je tak samo, ale po typie nazwie pola podaje dodatkowo, po dwukropku, iloœæ bitów, które zamierzamy przeznaczyæ na dane pole. 




14. Tablice 


Poniewa¿ istotê tablic naj³atwiej jest pokazaæ na przyk³adach, to w nastêpnych kilku podpunktach zostan¹ zaprezentowane przyk³adowe programy. Jednak zanim do nich dojdziemy przedstawiê ich podstawowe cechy.
Tablic u¿ywa w przypadku, gdy chcemy przechowywaæ du¿¹ iloœæ danych tego samego typu przy zachowaniu ³atwego do nich dostêpu. Mimo tego, ¿e tablica mo¿e przechowywaæ wiele danych jednego typu, odwo³ujemy do niej za pomoc¹ jednej nazwy. Jednak aby móc okreœliæ, o który dok³adnie element nam chodzi, musimy u¿yæ dodatkowo indeksu, czylkolejnego (liczonego od zera) numeru elementu. Kolejne elementy s¹ umiejscowione w pamiêckomputera jeden za drugim. Aby lepiej to zobrazowaæ przedstawiê na rysunku piêcioelementow¹ tablicê, której elementy s¹ typu float: 



Jak widzimy na rysunku pocz¹tek tablicy jest umiejscowiony w pamiêckomputera pod adresem 1000 (to oczywiœcie jest tylko przyk³ad, tablica ta mo¿e znajdowaæ sie pod zupe³nie innym adresem). W³aœnie pod tym adresem znajduje element tablicy o numerze zero - w naszym przypadku ma on wartoœæ trzy. Nastêpny element o numerze jeden, który zawiera wartoœæ piêæ, znajduje pod adresem 1004. Zapewne powiesz: "Zaraz, zaraz - przecie¿ elementy w tablicy mia³y byæ umiejscowione w pamiêcjeden za drugim. Dlaczego wiêc nie znajduje on pod adresem 1001 ?". Otó¿ dlatego, ¿e tablica ta zawiera elementy typu float. A jak zapewne pamiêtasz z punktu trzeciego, na przechowanie danej tego typu potrzeba a¿ czterech bajtów pamiêci. Z tego te¿ powodu mamy do czynienia z tak¹ sytuacj¹, ¿e kolejne elementy tablicy s¹ umiejscowione w pamiêcpod adresamró¿ni¹cymo cztery. Na zakoñcaenie tego punktu podam jeszcze jedn¹ wa¿n¹ cechê tablic - adres tablicy jest sta³y. Raz przydzielony nie zmienia przez ca³y czas dzia³ania programu. I jeszcze jedna informacja dla osób znaj¹cych pascala - odpowiednikiem konstrukcju¿ytych w nastêpnych podpunktach jest konstrukcja "array [0..x] of typ". 



14.1. Tablice o elementach typu prostego 


W poprzednim punkcie zosta³y przedstawione ogólne informacje dotycz¹ce tablic. Poniewa¿ jednak suchy tekst  nie wyjaœntematu tak dobrze jak przyk³ad, pos³u¿ymy w³aœnie tym narzêdziem. Za³ó¿my, ¿e chcemy napisaæ program, który obliczy nam œredni¹ z piêciu ocen. Bêdzie on wygl¹da³ nastêpuj¹co: 




#include &ltstdio.h>

void main(void) {
  float srednia;
  int   i;
  float oceny[5];

  // wpisujemy do tablicy przykladowe oceny z pieciu przedmiotow
  oceny[0] = 3; oceny[1] = 5; oceny[2] = 5; oceny[3] = 3.5; oceny[4] = 3;

  // sumujemy wszystkie oceny
  srednia = 0;
  for(i=0; i<5; i++) srednia += oceny[i];

  // dzielimy sume przez ilosc ocen
  srednia /= 5;

  // wypisujemy wynik na ekranie
  printf("Srednia ocen wynos%1.1f\n", srednia);
}



Na pocz¹tku programu nie ma nic nowego - w³¹czenie pliku nag³ówkowego, deklaracja dwóch zmiennych o nazwach srednia i. Jednak w nastêpnej linijce jest nowa rzecz - jak zapewne ju¿ domyœli³eœ jest to w³aœnie deklaracja tablicy. Przyjrzyjmy jej uwa¿nie - wygl¹da ona praktycznie identycznie, jak deklaracja zwyk³ej zmiennej. Najpierw wpisujemy typ danych, nastêpnie nazwê naszej tablicy (tutaj oceny). Ró¿nica pomiêdzy deklaracj¹ zwyk³ej zmiennej, a tablic¹ jest widoczna w ostatnim cz³onie. Przy deklaracjtablicy musimy jeszcze podaæ jej wielkoœæ. Robto podaj¹c t¹ wartoœæ w nawiasach klamrowych. W naszym przypadku chcemy obliczyæ œredni¹ z piêciu ocen, tak wiêc zadeklarowaliœmy tablicê o wielkoœcpiêæ.
Do poszczególnych elementów w tablicy odwo³ujemy przy pomocy indeksu. Indeks jest liczony od zera, tak wiêc w naszym przypadku do poszczególnych elemetów tablicy mo¿emy dostaæ u¿ywaj¹c indeksów o numerach od zera do cztery. Pokazane jest to w nastêpnej linijce programu - wpisujemy tu kolejne oceny do tablicy. W³asnie w dostêpie poprzez indeks tkwca³a si³a tablic. Szczególnie objawia to w dwóch nastêpnych linijkach programu. Pomyœl co by by³o, gdybyœ chcia³ wykorzystaæ zwyk³e zmienne zamiast tablic - musia³byœ zadeklarowaæ piêæ osobnych zmiennych typu float (np. o nazwach ocena1, ocena2... itd.), a nastêpnie wpisaæ coœ takiego: 
 srednia = ocena1 + ocena2 + ocena3 + ocena4 + ocena5;
 srednia /= 5;
Przy tej iloœcocen do zsumowania jest to jeszcze akceptowalne, ale jeœlby³oby ich wiêcej to linijka ta koszmarnie by wyd³u¿y³a. Dziêktemu zaœ, ¿e do tablicy mo¿emy odwo³ywaæ sie u¿ywaj¹c indeksu, mogliœmy zawrzeæ ca³e sumowanie w pojedynczej pêtlprzebiegaj¹cej od zera do czterech. W ka¿dym jej przebiegu zmienna srednia zostaje zwiêkszona o wartoœæ, która jest zawarta w elemencie tablicy o numerze i. Po ca³kowitym wykonaniu pêtlzmienna srednia zawiera sumê wszystkich elementów tablicy wystarczy j¹ tylko podzieliæ przez ich iloœæ (w naszym przypadku przez piêæ), aby otrzymaæ œredni¹ ocen, która zostanie wyœwietlona w ostatniej linijce programu. 



14.2. Tablice struktur 


Oprócz tablic, których elementy bêd¹ typu prostego, w jêzyku C mo¿na tak¿e budowaæ bardziej z³o¿one tablice. Dla przyk³adu w tym punkcie utworzymy tablicê struktur. Za³ózmy, ¿e mamy do czynienia z bardzo ma³¹ firm¹, w której pracuje trzech pracowników. Dla ka¿dego pracownika chcemy mieæ mo¿liwoœæ wyœwietlenia informacjo jego pensj numerze identyfikacyjnym. Poza tym chcemy tak¿e, aby program wyœwietla³ raport o kwocie, któr¹ bêdziemy musielco miesi¹c przeznaczyæ na wyp³aty dla pracowników. Program realizuj¹cy te zadania bêdzie wygl¹da³ nastêpuj¹co: 




#include &ltstdio.h>

typedef struct {
  int nr_id;
  float pensja;
} PRACOWNIK;

void main(void) {
  float     suma_wyplat;
  int       i;
  PRACOWNIK kadra[3]={ {25803, 1299.10}, {25809, 2100}, {7, 1500} };

  // wyswietlamy informacje o pracowniku - jego nr id,  pensje
  for(i=0; i<3; i++)
    printf("Nr identyfikacyjny: %d\nPensja: %5.2f\n\n",
           kadra[i].nr_id, kadra[i].pensja);

  // obliczamy kwote potrzebna na wyplaty
  suma_wyplat = 0;
  for(i=0; i<3; i++) suma_wyplat += kadra[i].pensja;

  printf("Suma wyplat wynosi: %5.2f\n", suma_wyplat);
}




Zacznijmy analizê tego programu. Pocz¹tek programu to dla nas nic nowego - deklaracja struktury o nazwie PRACOWNIK  dwóch zmiennych. Nastêpna linijka te¿ wygl¹da ju¿ znajomo, mamy tu deklaracjê tablicy o nazwie kadra, której elementy s¹ struktur¹ PRACOWNIK. Jednak mamy tu tak¿e przyk³ad pokazuj¹cy w jaksposób mo¿emy od razu zainicjalizowaæ tablicê. Tak jak to by³o w przypadku "zwyk³ych" zmiennych po nazwie stawiamy znak równoœci, a nastêpnie wartoœæ, któr¹ chcemy przypisaæ. Jednak o ile w tamtym przypadku od razu wpisywaliœmy liczbê, czy te¿znak, to teraz jest to trochê bardziej skomplikowane. Wszystkie wartoœci, które chcemy wpisaæ do tablicy musimy zawrzeæ w nawiasach klamrowych, oddzielaj¹c je od siebie przecinkami. W naszym przypadku mamy jednak do czynienia z sytuacj¹, gdzie ka¿dy element tablicy jest tak¿e typem z³o¿onym. Musimy wiêc zastosowaæ t¹ technikê tak¿e oddzielnie dla ka¿dego elementu tablicy, wpisuj¹c w nawiasach klamrowych wartoœcposzczególnych pól struktury - pierwsza wartoœæ zostanie przypisana polu nr_id, natomiast druga wartoœæ polu pensja. Tylko na pierwszy rzut oka wydaje to strasznie zagmatwane. Wystarczy jednak uruchomiæ program porównaæ wynikwyœwietlone na ekranie z wartoœciamwpisanymw tej linijce wszystko stanie jasne. Dobrze, przejdŸmy do analizy nastêpnej linijki. Mamy tu do czynienia z podobn¹ sytuacj¹ jak w poprzednim punkcie. Pêtla przebiega po kolewszystkie elementy tablicy, jednak o ile w poprzednim programie by³y one sumowane, to w tym s¹ po prostu wyœwietlane na ekranie. Mamy tu tak¿e przyk³ad odwo³wania do poszczególnych pól struktury, która jest elementem tablicy. Tak jak to by³o w przypadku jednej zmiennej strukturalnej, odwo³ujemy do poszczególnych pól oddzielaj¹c je od nazwy zmiennej przy pomocy kropki. Ostatnie trzy linijkprogramu s¹ praktycznie identyczne do tych, które by³y w poprzednim programie - po prostu sumujemy wartoœcpól pensja wszystkich elementów tablicy sumê t¹ wpisujemy do zmiennej suma_wyplat. Otrzyman¹ wartoœæ wypisujemy na ekranie w ostatniej linijce programu. 



14.3. Tablice o wielkoœcustalanej przy kompilacj


W tym punkcie zostanie przedstawiona jeszcze jedna ciekawa cecha tablic w jêzyku C, a mianowicie okreœlanie wielkosætablicy przez kompilator na podstawie danych podanych przy jej automatycznej inicjalizacji. Rozwa¿my program z poprzedniego punktu, jednak zapisany w nieco inny sposób: 




#include &ltstdio.h>

typedef struct {
  int nr_id;
  float pensja;
} PRACOWNIK;

void main(void) {
  float     suma_wyplat;
  int       i;
  PRACOWNIK kadra[]={ {25803, 1299.10}, {25809, 2100}, {7, 1500} };
  int       wielkosc = sizeof(kadra) / sizeof(PRACOWNIK);

  // wyswietlamy informacje o pracowniku - jego nr id,  pensje
  for(i=0; < wielkosc; i++)
    printf("Nr identyfikacyjny: %d\nPensja: %5.2f\n\n",
           kadra[i].nr_id, kadra[i].pensja);

  // obliczamy kwote potrzebna na wyplaty
  suma_wyplat = 0;
  for(i=0; < wielkosc; i++) suma_wyplat += kadra[i].pensja;

  printf("Suma wyplat wynosi: %5.2f\n", suma_wyplat);
}




Z pocz¹tku program ten wydaje byæ identyczny jak poprzedni. Pierwsza ró¿nica wystêpuje dopiero w linijce, w której mamy deklaracjê tablicy. Zauwa¿, ¿e w nawiasach kwadratowych nie zosta³a podana jej wielkoœæ. Jednak mimo tego konstrukcja taka jest poprawna, poniewa¿ kompilator mo¿e domyœliæ wielkoœctablicy na podstawie iloœcdanych wprowadzonych w czêœcinicjalizacyjnej. Poniewa¿ wpisaliœmy tam dane o trzech pracownikach to kompilator utworzy tablicê o trzech elementach. Jednak wynika z tego dla nas nastêpne zadanie - musimy okreœliæ ile pracowników zawiera tablica, aby móc wyœwietliæ dane na ekranie. Poprzednio mieliœmy na sta³e ustawion¹ wielkoœæ tablicy na trzy, tak wiêc obie pêtle for ustawiliœmy tak, aby wykona³y trzykrotnie. Zastanawiasz zapewne po co w takim razie zastosowaliœmy tak¹ konstrukcjê, skoro musimy wykonywaæ dodatkowe prace aby program dzia³a³ tak jak poprzednio. Otó¿ rozwi¹zanie jest proste - pomyœl co by by³o gdybyœ zatrudni³ czwartego pracownika. Musia³byœ wpisaæ go do tablicy zmieniæ jej wielkoœæ na cztery. Jednak to nie wszystko - we obu pêtlach musia³byœ tak¿e zmieniæ warunek kontynuacjtak, aby wykonywa³y cztery razy. A przy zastosowaniu konstrukcju¿ytej w tym programie jedyne co bêdziesz musia³ zrobiæ, to wpisaæ nowego pracownika do tablicy - reszta wykona automatycznie. Dodatkowy pracê, polegaj¹c¹ na napisaniu wyra¿enia obliczaj¹cego wielkoœæ tablicy bêdziesz musia³ wykonaæ tylko jeden raz - podczas pisania programu. Korzyœcs¹ chyba oczywiste ? PrzejdŸmy wiêc do nastêpnej linijki, która obliczy iloœæ elementów w tablicy. Zastanówmy w jaksposób mo¿aby obliczyæ t¹ wartoœæ. Najproœciej jest chyba podzieliæ wielkoœæ ca³ej tablicy przez wielkoœæ pojedynczego jej elementu - w³aœnie ten sposób jest zastosowany w naszym programie. Aby uzyskaæ wielkoœæ jakiejœ danej musimy u¿yæ funkcjsizeof . Zwraca ona wielkoœæ (w bajtach) podanej jako parametr danej. W naszym przypadku u¿yliœmy jej dwa razy. Najpierw do okreœlenia wielkoœcca³ej tablicy - "sizeof(kadra)", a nastêpnie do okreœlenia wielkoœcpojedynczego jej elementu (w naszym przypadku struktury PRACOWNIK) - "sizeof(PRACOWNIK)". Po podzieleniu pierwszej wartoœcprzez drug¹ otrzymaliœmy iloœæ elementów w tablicy, któr¹ to iloœæ przypisaliœmy zmiennej o nazwie wielkosc. Teraz, maj¹c iloœæ elementów w tablicy, jedyne co musimy zrobiæ to zamieniæ w stosunku do poprzedniego programu obie trójkw pêtlfor na nasz¹ zmienn¹ wielkosc to wszystko ! Program dzia³a zgodnie z naszymzamierzeniami. 



14.4. Tablice wielowymiarowe 


Oprócz jednowymiarowych tablic poznanych w poprzednich podpunktach, jêzyk C umo¿liwia tworzenie tablic wielowymiarowych. Ich zastosowanie zostanie pokazane na przyk³adzie dwuwymiarowej tablicy, która bêdzie odpowiada³a planszy do gry "w statki." Jako za³o¿enie programu przyjmiemy, ¿e polu pustemu odpowiada wartoœæ zero w tablicy, natomiast jeœlna danym polu znajduje jakiœ statek, to ma ono wartoœæ jeden. Poza tym dla uproszczenia programu postawimy dla planszy tylko trzy statkjednomasztowe. A oto jak wygl¹da takprogram: 




#include &ltstdio.h>

void main(void) {
  int plansza[10][10];
  int i, j;

  // wyczyszczenie planszy - wypelnienie jej zerami
  for(i=0; i<10; i++)
    for(j=0; j<10; j++)
      plansza[i][j] = 0;
    
  // ustawienie trzech jednomasztowcow
  plansza[3][6] = 1; plansza[8][3] = 1; plansza[2][9] = 1;

  // wyswietlenie informacjna ktorych polach znajduja sie statki
  for(i=0; i<10; i++)
    for(j=0; j<10; j++)
      if(plansza[i][j]) printf("Statek znajduje sie na polu %d,%d\n", i, j);

}



Zaraz w pierwszej linijce funkcjmain mamy do czynienia z deklaracj¹ tablicy dwuwymiarowej. Jak widzisz nie ró¿nona mocno od deklaracjzwyk³ej, jednowymiarowej tablicy. Jedyn¹ ró¿nic¹ jest to, ¿e wystêpuj¹ tu dwie sekcje z nawiasamkwadratowymi, które okreœlaj¹ wielkoœcposzczególnych wymiarów tablicy. W naszym przyk³adzie obie maj¹ wielkoœæ dziesiêæ, choæ oczywiœcie mog¹ mieæ ró¿ne wymiary. Jeœlchcia³byœ utworzyæ tablicê o wiêcej ni¿ dwóch wymiarach, to wystarczy, ¿e dopiszesz jeszcze jedn¹, lub wiêcej takich sekcji. Nastêpnie mamy wyczyszczenie naszej tablicy zerami. Odbywa to przy pomocy dwóch pêtlfor przebiegaj¹cych od zera do dziewiêciu. Pêtla zewnêtrzna, w której zwiêkszana jest zmienna odpowiada poszczególnym wierszom, natomiast pêtla wewnêtrzna poszczególnym kolumnom tablicy. Masz tu tak¿e przyk³ad w jaksposób mo¿na odwo³ywaæ do poszczególnych elementów tablicy wielowymiarowej. Ró¿nica jest taka, jak przy deklaracj- wystarczy dodaæ dodatkow¹ sekcjê z nawiasamkwadratowymi, w których wpisujemy indeks dla danego wymiaru. W nastêpnej linijce ustawiamy na planszy trzy statkjednomasztowe, czylpo prostu w trzech miejscach w tablicy wpisujemy wartoœæ jeden. Ostatnie trzy linijks³u¿a do wyœwietlenia informacji, na których polach znajduj¹ statki. Sprawdzamy po kolewszystkie elementy tablicy (czylnaszej planszy do gry) jeœlktórymœ z nich ma wartoœæ ró¿n¹ od zera to wyœwietlamy informacjê o pozycjstatku. 



14.5. Tablice jako parametr funkcj


D³ugo zastanawia³em, czy napisaæ o tym ju¿ teraz, w tym punkcie, czy te¿ dopiero w nastêpnym - ju¿ po wyjaœnieniu istoty wskaŸników. Jednak zdecydowa³em umieœciæ to tutaj, gdy¿ mimo wszystko informacje te dotycz¹ g³ównie tablic. Jednak jeœlbêdziesz mia³ problemy ze zrozumieniem tego podpunktu to przeczytaj najpierw nastêpny punkt o wskaŸnikach, a nastêpnie powróæ do czytania tego podpunktu. 

Na koniec wyk³adu o tablicach pozosta³a nam jeszcze do omówienia jedna rzecz, a mianowicie przekazywanie tablic do funkcjjako jeden z parametrów. Wiesz ju¿ co to s¹ funkcje  jak przekazywaæ do nich zmienne jako ich parametry, tak wiêc z sam¹ sk³adniow¹ stron¹ tego problemu nie powinieneœ mieæ k³opotów. Jedynym problemem mo¿e byæ zrozumienie istoty przekazywania tablic, ale myœlê, ¿e nawet jeœlteraz tego nie zrozumiesz, to po przeczytaniu nastêpnego punktu zrozumiesz to z pewnoœci¹.
Jak zapewne pamiêtasz z wczeœniejszych punktów, w jêzyku C mamy do czynienia z tzw. przekazywaniem przez wartoœæ parametrów do funkcji. Znaczy³o to, ¿e nawet jeœlw ciele funkcjzmienna, która zosta³a do niej przekazana zosta³a zmieniona (tzn. przypisano jej now¹ wartoœæ) to po powrocie do miejsca wywo³ania funkcjmia³a dalej star¹ wartoœæ. Po prostu w momencie wywo³ania funkcjzosta³a utworzona kopia zmiennej, która zosta³a przekazana jako parametr zmianom ulega³¹ w³aœnie ta kopia, a nie oryginalna zmienna. Od regu³y tej jest jednak pewien wyj¹tek. Jak zapewne domyœlasz wyj¹tkiem tym jest przekazywanie do funkcjtablic. Zwi¹zane jest to z tym, ¿e tablice mog¹ mieæ na prawdê ogromn¹ wielkoœæ przy tworzeniu ich kopimog³oby np. zabrakn¹æ wolnej pamiêci. Poza tym samo kopiowanie trwa³o by doœæ d³ugo, a jêzyk C by³ zaprojektowany z myœl¹ o jak najszybszym dzia³aniu programów w nim napisanych. Tablice w jêzyku C nie s¹ wiêc przekazywane przez wartoœæ, lecz zamiast tego przekazuje tzw. wskaŸnik do pierwszego elementu. Innyms³owy do funkcjprzekazuje adres pamiêci, pod którym znajduje pierwszy element tablicy (u³o¿enie tablicy w pamiêczosta³o omówione na pocz¹tku tego punktu).
Aby pokazaæ sposób w jakmo¿esz przekazaæ tablicê do funkcj udowodniæ fakt, ¿e nie s¹ one przekazywane przez wartoœæ napisa³em program, który to zademonstruje. Przed dalsz¹ lektur¹ skompiluj go proszê, uruchom przyj¿yj uwa¿nie wynikom jego dzia³ania. 




#include &ltstdio.h>

int Suma(int tab[], int ilosc) {
  int i, suma;

  // obliczenie sumy wszystkich wartoscw tablicy
  suma = 0;
  for(i=0; < ilosc; i++) suma += tab[i];

  // robimy to aby udowodnic, ze tablica nie jest, natomiast zwykla zmienna
  // jest przekazywana przez wartosc
  tab[ilosc-1] = 11; ilosc = 100;

  return suma;
}

void main(void) {
  int tablica[]={6, 3, 123, 3, 5, 200};
  int ilosc = sizeof(tablica) / sizeof(int);

  printf("Przed wywolaniem funkcjostatnelement jest rowny %d.\n",
          tablica[ilosc-1]);
  printf("Przed wywolaniem funkcjzmienna ilosc jest rowna %d.\n",
          ilosc);

  printf("Suma wszystkich elementow jest rowna %d.\n", Suma(tablica, ilosc));

  printf("Po wywolaniu funkcjostatnelement jest rowny %d.\n",
          tablica[ilosc-1]);
  printf("Po wywolaniu funkcjzmienna ilosc jest rowna %d.\n",
          ilosc);
}




Wiêkszoœæ konstrukcju¿ytych w tym programie powinna byæ dla Ciebie zrozumia³a. Praktycznie wszystko by³o ju¿ u¿yte w poprzednich programach, z jednym wyj¹tkiem, a mianowicie deklaracj¹ pierwszego parametru funkcjSuma jako tablicy. Przyjrzyj sposobowdeklaracj- wygl¹da ona bardzo podobnie jak deklaracja parametru typu prostego. Jedyn¹ ró¿nic¹ jest to, ¿e po nazwie podaliœmy jeszcze nawiasy klamrowe. Czyl
int Suma(int tab[], int ilosc)
przeczytamy jako: definicja funkcjo nazwie Suma zwracaj¹cej wartoœæ typu int, która przyjmuje dwa parametry, z których pierwszy jest typu tablica intów nazywa tab, natomiast drugjest typu int nazywa iloœæ.
Skoro ju¿ wiesz wszystko co potrzebne odnoœnie sk³adnzastosowanej w programie mo¿emy przejœæ do jego analizy.
Zaczynamy, jak zwykle, od funkcjmain . Pocz¹tek to nic nowego - deklaracja tablicy intów o wielkoœcautomatycznie obliczanej przez kompilator  deklaracja zmiennej o nazwie ilosc, która t¹ wielkoœæ bêdzie przechowywaæ. Nastêpnie, przy pomocy funkcjprintf , wyœwietlamy na ekranie zawartoœæ ostatniego elementu tablicy  iloœæ elementów w niej zawartych. Nastêpnej linijce bêdziemy musielprzygl¹dn¹æ dok³adniej - zawiera ona wywo³anie funkcjSuma . Wartoœæ, któr¹ ta funkcja zwróci³a zostaje przekazana jako parametr do funkcjmain zostaje wyœwietlona na ekranie. Funkcja Suma oblicza sumê tylu elementów tablicy, która zosta³a przekazana jako pierwszy parametr, ile zost³o przekazanych jako parametr numer dwa. W naszym przypadku funkcja ma obliczyæ sumê wszystkich (bo zmienna iloœæ zawiera iloœæ elementów w tablicy) tablicy o nazwie... tablica. Przyj¿yj dok³adnie sposobowi, w jakprzkazaliœmy oba parametry do funkcjSuma - po prostu podaliœmy nazwy zmiennych. Skoro wywo³aliœmy nasz¹ funkcjê to przejdŸmy do analizy jej wnêtrza. Pocz¹tek to nic nowego - sumujemy elementy tablicy w sposób taki, jak w poprzednich programach uzyskan¹ wartoœæ przypisujemy zmiennej o nazwie suma. Wartoœæ t¹ zwracamy do miejsca wywo³ania przy u¿yciu return w ostatniej linijce cia³a funkcji. Jednak we wczeœniejszej linijce u¿yliœmy dwóch przypisañ, aby zaprezentowaæ to, o czym wspomnia³em na pocz¹tku tego podpunktu - tablice s¹ przekazywane przez wskaŸnik, w przeciwieñstwie do innych typów przekazywanych przez wartoœæ. Aby to udowodniæ do ostatniego elementu tablicy wpisaliœmy liczbê jedenaœcie (na pocz¹tku by³o tam dwieœcie), natomiast zmiennej ilosc przypisaliœmy wartoœæ sto (by³a tam pocz¹tkowo wartoœæ szeœæ poniewa¿ tyle w³aœnie jest elementów w naszej tablicy). Po wykonaniu funkcjwyœwietlamy ponownie zawartoœæ obu tych danych, aby sprawdziæ czy fakt, ¿e zmodyfikowaliœmy je w funkcjreturn ma jakiekolwiek znaczenie. A oto jakjest wynik wyœwietlony na ekranie po uruchomieniu tego programu: 
 Przed wywolaniem funkcjostatnelement jest rowny 200.
 Przed wywolaniem funkcjzmienna ilosc jest rowna 6.
 Suma wszystkich elementow jest rowna 340.
 Po wywolaniu funkcjostatnelement jest rowny 11.
 Po wywolaniu funkcjzmienna ilosc jest rowna 6.
Jak widzisz wynika z tego jednoznacznie, ¿e o ile w przypadku zmiennej ilosc jej wartoœæ w ogóle nie zmieni³a, to w przypadku tablicy jej wartoœæ uleg³a zmianie. 

Mimo faktu, ¿e jêzyk C nie posiada tzw. przekazania przez referencjê (czylodpowiednika var z pascala) to jednak sposób, który kompilator wykorzystuje przy przekazywaniu tablic do funkcji, mo¿emy samodzielnie zastosowaæ tak¿e w stosunku do typów prostych przy zastosowaniu tzw. wskaŸników. Jest to jednak temat na tyle obszerny, ¿e poœwiecony zostanie temu zagadnieniu ca³y nastêpny punkt. 




15. WskaŸnik


Z ogólnyminformacjamdotycz¹cymwskaŸników zapoznamy siê, podobnie jak to by³o w przypadku tablic, przy pomocy przyk³adowego rysunku. 



Za³ó¿my, ¿e zadeklarowaliœmy sobie w programie zmienn¹ typu int o nazwie x od razu przypisaliœmy jej wartoœæ 124. Czylwygl¹da³oby to nastêpuj¹co: 
int x=124;
Za³ó¿my teraz, ¿e kompilator umieœci³ nasz¹ zmienn¹ w pamiêcpod adresem 1000. Czylwygl¹da³oby to tak jak na rysunku przedstawionym powy¿ej. Spróbój teraz wczuæ w rolê kompilatora w przypadku, gdy w swoim programie ka¿desz mu wykonaæ nastêpuj¹ce polecenie: 
 = x;
Czyldo jakiejœ zmiennej o nazwie (która jest tu nieistotna) przypisujesz wartoœæ zmiennej x. Pomyœl co muszrobiæ kompilator, ¿eby wykonaæ to polecenie. Interesuje nas sk¹d kompilator wie jak¹ wartoœæ ma nasza zmienna x ? OdpowiedŸ brzmi: nie wie. Jednak wie, w którym miejscu pamiêcznajduje zmienna. Sprawdza wiêc jakjest jej adres - w naszym przypadku jest to adres 1000. Nastêpnie odczytuje komórkê pamiêcznajduj¹c¹ pod tym adresem voila ! Otrzymuje w efekcie liczbê 124, która tam znajduje. Zastanawiasz teraz zapewne po co Cto wszystko mówiê ? Otó¿ podobnie, z naszego (czylprogramisty) punktu widzenia, dzia³aj¹ wskaŸniki. Za³ó¿my, ¿e oprócz naszej zmiennej x mamy jeszcze jedn¹ zmienn¹ (której deklaracjna razie nie podam), która ma wartoœæ 1000. W naszym przypadku jest ona umieszczona pod adresem 1016. Przypatrz teraz uwa¿nie rysunkowi. Czy nic nie wydaje Cpodejrzane ? Nasza druga zmienna zawiera wartoœæ, która jest równa adresowzmiennej x ! T¹ drug¹ zmienn¹ nazywamy wskaŸnikiem w przypadku, gdy chcemy odczytaæ zawartoœæ komórkpamiêco adresie, który jest zawarty w tej zmiennej to mówimy kompilatorow(oczywiœcie przy pomocy odpowiedniej sk³adni): "S³uchaj, podaj mzawartoœæ komórkpamiêci, której adres jest zawarty w tej oto zmiennej (tu j¹ podajemy)". Kompilator oczywiœcie stosuje do naszego polecenia w efekcie mamy to o co nam chodzi³o.
To by by³o na tyle jeœlchodzo wyjaœnienie pojêcia wskaŸnika. W nastêpnych podpunktach zostan¹ pokazane na podstawie przyk³adowych programów sposoby ich deklaracjwykorzystania. Mam proœbê, ¿ebyœ ten punkt czyta³ szczególnie uwa¿nie, gdy¿ jest to temat, który po pierwsze jest trudny, a po drugie bardzo wa¿ny. Praktycznie nie ma ¿adnego powa¿niejszego programu, który nie operowa³by na wskaŸnikach. 

I jeszcze jedna uwaga na koniec tego wstêpu do wskaŸników. Nie bierz, proszê, zbyt dos³ownie sposobu odczytu watoœczmiennej przez kompilator. Opisa³em sposób, w jakrobi³by to gdyby by³ cz³owiekiem. Kompilator cz³owiekiem jednak nie jest robto w rzeczywistoœctrochê inaczej. Z Twojego punktu widzenia nie jest jednak wa¿ne jak, wa¿ne jest to, ¿eby zrobi³ to dobrze. Zastosowa³em tak¹ formê opisu w takim celu, ¿ebyœ móg³ ³atwiej zrozumieæ istotê wskaŸników. Mam nadziejê, ¿e dziêktemu uda mwyjaœniæ ten trudny dla pocz¹tkuj¹cego temat w sposób przystêpny. 



15.1 Pierwszy program korzystaj¹cy ze wskaŸników 


Poniewa¿ masz ju¿ teoretyczne podstawy nadszed³ ju¿ czas, aby zaprezentowaæ istotê wskaŸników w praktyce. A oto nasz pierwszy program, w którym wykorzystamy wskaŸniki: 




#include &ltstdio.h>

void main(void) {
  int a;
  int *b;

  a = 11;
  printf("Zmienna a jest rowna %d\n", a);

  b = &a;
  printf("Wartosc wskazywana przez wskaznik b wynos%d\n", *b);

  *b = 14;
  printf("Zmienna a jest rowna %d\n", a);
}



Zanim przejdziesz do dalszego czytania kursu skompiluj uruchom powy¿szy program. Na ekranie powinno pojawiæ siê: 

Zmienna a jest rowna 11
Wartosc wskazywana przez wskaznik b wynos11
Zmienna a jest rowna 14
Jak zwykle przejdziemy teraz do analizy naszego programu. Na pocz¹tku mamy zwyk³¹ deklaracjê zmiennej o nazwie a, która jest typu int. Jednak ju¿ w nastêpnej linijce mamy coœ nowego - jak domyœlasz jest to deklaracja wskaŸnika. Zauwa¿ jak niewiele ró¿nona od deklaracjzwyk³ej zmiennej. Na pocz¹tku piszemy jakiego typu bêdzie nasz wskaŸnik (tutaj jest to wskaŸnik na int), a nastêpnie nazwê zmiennej, któr¹ jednak, w odró¿nieniu od deklaracjzwyk³ej zmiennej, poprzedzamy gwiazdk¹. Nastêpne kilka linijek ma za zadanie pokazaæ istotê wskaŸników. Mam nadziejê, ¿e to co po wyjaœnieniu teoretycznym mog³o wydawaæ niejasne, teraz stanie zrozumia³e. Pierwsze dwie linijktego fragmentu to nic nowego - zmiennej a&mbsp; przypisujemy wartoœæ jedenaœcie nastêpnie wyœwietlamy j¹ na ekranie. Jednak w nastêpnej linijce mamy do czynienia z now¹ konstrukcj¹. Do zmiennej b (która, jak zapewne pamiêtasz, jest typu wskaŸnik na int) przypisujemy adres zmiennej a. Aby otrzymaæ adres danej zmiennej wystarczy postawiæ przed ni¹ znak ampersand "&". Tak wiêc wyra¿enie "&a" okreœla nam adres zmiennej a. Zwróæ uwagê na to, co zosta³o podkreœlone - adres, a nie wartoœæ ! Tak jak to by³o w wyjaœnieniu teoretycznym: jeœlnasza zmienna a znajdowa³aby w pamiêckomputera pod adresem 1000 to zmienna b bêdzie mia³a wartoœæ 1000, a nie 11 (która jest wartoœci¹ przechowywan¹ przez zmienn¹ a). Nastêpna linijka pokazuje jak odczytaæ wartoœæ wskazywan¹ przez zmienn¹ b - wystarczy przed nazw¹ zmiennej wskaŸnikowej postawiæ gwiazdkê. Zapamiêtaj wiêc: jeœlb jest zmienn¹ wskaŸnikow¹ to wyra¿enie "b" okreœla nam adres, który jest przechowywany w tej zmiennej, natomiast wyra¿enie "*b" okreœla wartoœæ przechowywan¹ w pamiêckomputera pod adresem, który zawiera ta zmienna. W nastêpnej linijce mamy pokazane do czego mo¿e nam to przydaæ. Mamy tu do czynienia z tak¹ oto sytuacj¹: 

*b = 14;
Pamiêtasz co oznacza³o wyra¿enie "*b" ? By³¹a to wartoœæ wskazywana przez zmienn¹ b. A poniewa¿ zmienna b wskazywa³¹ na zmienn¹ a (wskazania tego dokonaliœmy w linijce "b = &a;") to mimo tego, ¿e w ca³ym tym wyra¿eniu nie jest wspomniana nawet zmienna a, to tak naprawdê dokonamy zmiany w³aœnie jej wartoœc! Aby to udowodniæ w nastêpnej linijce wypisujemy na ekranie wartoœæ zmiennej a - rzeczywiœcie jest ona teraz równa czternaœcie. Jeœlci¹gle nie wiesz  to przeczytaj uwa¿nie jeszcze raz ten podpunkt ( podpunkt teoretyczny). Jest to niezmiernie wa¿ne, gdy¿ bez jego zrozumienia nie uda Czrozumieæ podpunktów nastêpnych. 



15.2 WskaŸnika tablice 


Miêdzy tymdwoma konstrukcjamw jêzyku C zachodzœcis³y zwi¹zek. Nazwa tablicy mo¿e byæ traktowana jako sta³y wskaŸnik do pierwszego jej elementu. Wynika z tego, ¿e tablicê mo¿na bezpoœrednio (bez rzutowania) przypisaæ do wskaŸnika (oczywiœcie zarówno tablica, jak wskaŸnik musz¹ byæ tego samego typu). Pokazuje to nastêpuj¹cy program: 




#include &ltstdio.h>

void main(void) {
  int tablica[3] = {5, 10, 15};
  int *wskaznik;
  int i;

  for(i=0; i<3; i++) 
    printf("tablica[%d] = %d\n", i, tablica[i]);

  wskaznik = tablica;
  for(i=0; i<3; i++, wskaznik++) 
    printf("*(wskaznik+%d) = %d\n", i, *wskaznik);
}



Na pocz¹tku deklarujemy trzyelementow¹ tablicê typu int (z automatyczn¹ inicjalizacj¹), jedn¹ zmienn¹ bêd¹c¹ wskaŸnikiem na int  "zwyk³¹" zmienn¹ typu int. Zaraz po deklaracjzmiennych u¿ywanych przez program wyœwietlamy w pêtlwartoœcposzczególnych elementów tablicy. Czylna razie nic nowego. To o czym traktuje ten podpunkt jest zawarte w nastêpnych trzech linijkach programu. W pierwszej z nich dokonujemy przypisania tablicy do wskaŸnika. Mo¿emy to zrobiæ, gdy¿, tak jak napisa³em we wstêpie do tego podpunktu, nazwa tablicy mo¿e byæ traktowana jako wskaŸnik do jej pierwszego elementu. Zapamiêtaj jednak ¿e ta operacja przypisuje wskaŸnikowadres pierwszego elementu tablicy, a nie jego wartoœæ ! Nastêpne dwie linijkpokazuj¹ z kolei, ¿e na wskaŸnikach mo¿na tak¿e dokonywaæ pewnych operacjarytmetycznych. W naszym przyk³adowym programie w pêtlfor dokonujemy zwiêkszenia wskaŸnika o jeden przy pomocy operatora ++ . Zapamiêtaj jednak, ¿e operacja ta zwiêksza wskaŸnik o jeden element typu, na który wskazuje wskaŸnik, a nie o jeden bajt ! CzyljeœlwskaŸnik wskazuje (tak jak w naszym przypadku) na int to operacja zwiêkszenia wskaŸnika spowoduje, ¿e zmienna wskaŸnikowa bêdzie zawiera³a adres nastêpnego elementu typu int (czylde facto bêdzie wiêksza o cztery bajty, bo tyle w³aœnie zajmuje int). W wiêkszoœcprzypadków wiedza ta co prawda nie bêdzie Cpotrzebna, ale czasammo¿e okazaæ przydatna (np. w sytuacjodnoszenia do tego samego obszaru pamiêcprzy pomocy ró¿nych wskaŸników). Ostatnia linijka programu ma za zadanie wyœwietlenie wartoœci, na któr¹ wskazuje nasz wskaŸnik. Zauwa¿, ¿e u¿yliœmy tu konstrukcj"*wskaznik" poniewa¿ w³aœnie w ten sposób otrzymujemy t¹ wartoœæ. 



15.3 WskaŸnikdo struktur 


Kolejnym zagadnieniem, które chcê poruszyæ jest u¿ywanie wskaŸników, które wskazuj¹ na strukturê. Odwo³ywanie do poszczególnych pól struktury jest nieco inne w takim przypadku, jednak ró¿nica jest minimalna. Pokazuje to poni¿szy program (który jest drobn¹ przeróbk¹ programu ju¿ wczeœniej przez nas analizowanego): 




#include &ltstdio.h>

typedef struct {
  int godziny;
  int minuty;
  int sekundy;
} CZAS;

void main(void)
{
  CZAS teraz={23,53,21};
  CZAS *wsk = &teraz;

  printf("Teraz jest %d:%d:%d\n", teraz.godziny, teraz.minuty, teraz.sekundy);
  printf("Teraz jest %d:%d:%d\n", wsk-godziny, wsk-minuty, (*wsk).sekundy);
}



Program ten ma za zadanie wyœwietliæ na ekranie godzinê, która zawarta jest w strukturze typu CZAS. Na pocz¹tku deklarujemy sobie zmienn¹ strukturaln¹ o nazwie teraz od razu przypisujemy jej konkretn¹ wartoœæ. W nastêpnej linijce mamy do czynienia z deklaracj¹ wskaŸnika na strukturê typu CZAS, któremu tak¿e przypisujemy od razu wartoœæ - w naszym przypadku inicjalizujemy go tak, aby wskazywa³ na nasz¹ zmienn¹ strukturaln¹ teraz. Nastêpne dwie linijkwyœwietlaj¹ na ekranie ten sam tekst tylko u¿ywaj¹c do tego celu ró¿nych zmiennych. W pierwszej z nich robimy to przy u¿yciu "normalnej" zmiennej strukturalnej - w takim przypadku, jak zapewne pamiêtasz, nazwê pola oddzielamy kropk¹. W drugiej linijce mamy do czyniania z sytacj¹, w której odwo³ujemy do pola struktury poprzez wskaŸnik do niej. W takim przypadku jedyn¹ ró¿nic¹ jest to, ¿e zamiast kropkstosujemy swego rodzaju strza³kê zbudowan¹ z dwóch znaków: minusa  znaku wiêkszoœci. W naszym programie odwo³ujemy w ten sposób do dwóch pierwszych pól: godziny minuty. Aby zademonstrowaæ inn¹ mo¿liwoœæ do pola sekundy odwo³aliœmy w nieco inny sposób. Jak zapewne pamiêtasz konstrukcja "*nazwa", gdzie nazwa jest wskaŸnikiem powoduje, ¿e w efekcie otrzymujemy wartoœæ, na któr¹ wskazuje nasz wskaŸnik. W tym przypadku w³aœnie to wykorzystaliœmy - u¿ycie konstrukcj"*wsk" powoduje, ¿e teraz mamy do czynienia z wartoœci¹, na któr¹ wskazuje zmienna wsk (w naszym przypadku jest to struktur¹ CZAS). A poniewa¿ mamy teraz do czynienia ze zwyk³¹ struktur¹ to do pola mo¿emy "dobraæ" przy pomocy zwyk³ej kropki. Nale¿y jednak tu pamiêtaæ o tym, aby "*wsk" zawrzeæ w nawiasach poniewa¿ operator * ma mniejszy priorytet od operatora . 



15.4 Dynamiczny przydzia³ pamiêc


Pamiêtasz tablice, prawda ? Wielkoœæ tablicy musia³a byæ ustalona ju¿ w momencie pisania programu. W przypadku prostych programów nie jest to problemem, ale co zrobiæ, gdy potrzebn¹ wielkoœæ tablicy bêdzie mo¿na okreœliæ dopiero po uruchomieniu programu ? Na przyk³ad dane o pracownikach jakiejœ firmy maj¹ byæ odczytywne z pliku - w takim przypadku, a¿ do momentu otwarcia pliku wielkoœæ ta nie jest znana. Mo¿na co prawda zadeklarowaæ tablicê o wielkoœcdu¿o wiêkszej ni¿ to prawdopodobnie bêdzie potrzebne, ale wia¿e z tym du¿e marnotrawstwo pamiêci. Poza tym mo¿e okazaæ siê, ¿e w pewnym momencie wielkoœæ ta tak nie bêdzie wystarczaj¹ca. Z pomoc¹ przychodz¹ nam wskaŸnikmo¿liwoœæ, któr¹ udostêpniaj¹ a mianowicie dynamiczny (czylju¿ w trakcie pracy programu) przydzia³ pamiêcoperacyjnej. Ich zastosowanie do tego celu poka¿emy jak zwykle na przyk³adowym programie. Aby nie wprowadzaæ niepotrzebnego zamieszania zdecydowa³em dokonaæ przeróbkprogramu ju¿ analizowanego (w podpunkcie poœwieconemu tablicom struktur). Omówione zostan¹ tu tylko ró¿nice. A oto program: 




#include &ltstdio.h>
#include &ltstdlib.h>

typedef struct {
  int nr_id;
  float pensja;
} PRACOWNIK;

void main(void) {
  int       i;
  PRACOWNIK *kadra;

  // przydzielamy pamiec na dynamiczna tablice
  kadra = (PRACOWNIK*) malloc(3 * sizeof(PRACOWNIK));

  // sprawdzenie czy udalo sie zaalokowac pamiec
  if(kadra != NULL) {
    printf("Brak pamiec!"); exit(0);
  }

  // wpisujemy wartoscdla poszczegolnych pracownikow
  kadra-nr_id = 25803; kadra-pensja = 1299.10;
  (kadra+1)-nr_id = 25809; (kadra+1)-pensja = 2100;
  (kadra+2)-nr_id = 7; (kadra+2)-pensja = 1500;

  // wyswietlamy informacje o pracowniku - jego nr id,  pensje
  for(i=0; i<3; i++)
    printf("Nr identyfikacyjny: %d\nPensja: %5.2f\n\n",
           kadra[i].nr_id, kadra[i].pensja);

  // zwalniamy przydzielona pamiec
  free(kadra);
}




Pierwsza ró¿nica jest ju¿ przy do³¹czaj¹ plików nag³ówkowych. Oprócz "standardowego" stdio.h do³¹czamy jeszcze stdlib.h . Plik ten zawiera deklaracje nowych funkcji, które u¿yjemy w naszym programie - malloc  free . PrzejdŸmy dalej - mamy tu deklaracjê struktury o nazwie PRACOWNIK, nastêpnie zmiennej i. W nastêpnej linijce natykamy na nastêpn¹ ró¿nicê - zamiast trzyelementowej tablicy struktur typu PRACOWNIK deklarujemy tu wskaŸnik na strukturê typu PRACOWNIK. Nastêpna linijka zawiera ju¿ ca³kiem now¹ rzecz - wywo³anie funkcjmalloc . Funkcja ta alokuje (przydziela dla programu) pamiêæ operacyjn¹ o wielkoœcpodanej przy wywo³aniu (w bajtach). W naszym przypadku ka¿emy przydzieliæ jej pamiêæ o wielkoœc"3 * sizeof(PRACOWNIK)". Jak zapewne pamiêtasz operator sizeof zwraca wielkoœæ w bajtach podanego parametru. Tak wiêc wynika z tego, ¿e kazaliœmy funkcjmalloc przydzieliæ tyle pamiêci, aby zmieœci³y w niej trzy struktury typu PRACOWNIK. Funkcja ta, w przypadku gdy przydzia³ pamiêcpowiód³, zwraca adres pierwszego zaalokowanego bajtu pamiêci. Poniewa¿ nasz wskaŸnik o nazwie kadra wskazuje na strukturê PRACOWNIK, a funkcja malloc zwraca wskaŸnik typu void* to musimy jeszcze dokonaæ rzutowania. Rzutowanie wska¿ników robw ten sam sposób jak rzutowanie typów prostych - jedynym wyj¹tkiem jest dodanie gwiazdkza nazw¹ typu. Tak wiêc, aby dokonaæ rzutowania wskaŸnika typu void* na wskaŸnik na strukturê PRACOWNIK musimy dodaæ jeszcze "(PRACOWNIK*)" dopiero teraz mo¿emy przypisaæ ten adres naszej zmiennej. Jak ju¿ do tego doszliœmy to wyjaœniê jeszcze zastosowanie wskaŸnika na void. Jak zapewne pamiêtasz s³owo kluczowe void okreœla brak typu. Nie mo¿na deklarowaæ zmiennych typu void, jedynym dopuszczalnym miejscem, gdzie mo¿na go u¿yæ jest okreœlenie typu, który zwraca funkcja. Natomiast wskaŸnika na void jak najbardziej mo¿na u¿ywaæ na dodatek jest on bardzo przydatny. Mo¿esz wiêc zadeklarowaæ sobie zmienn¹ typu wskaŸnik na void. Bardzo wa¿n¹ zalet¹ tego wskaŸnika jest to, ¿e mo¿esz dokonaæ przypisania na niego dowolnego innego wskaŸnika. Oczywiœcie, z uwagna to, ¿e typ na który on wskazuje nie jest okreœlony nie mo¿esz dokonywaæ na nim operacjarytmetycznych. Dobrze to taka ma³a dygresja, wróæmy do analizy naszego programu. Otó¿ napisa³em, ¿e funkcja malloc zwraca nam adres przydzielonego bloku pamiêci. Co jednak jest w sytuacji, gdy przydzia³ pamiêcnie jest mo¿liwy np. w sytuacji, gdy próbujemy sobie zaalokowaæ 100 MB pamiêcna komputerze wyposa¿onym w tylko 32 MB (pomijam tu istnienie pamiêcwirtualnej). Otó¿ w takim przypadku zamiast adresu zwrócona zostaje wartoœæ NULL . Jest to specjalnie zadeklarowana wartoœæ mówi¹ca o tym, ¿e wskaŸnik jest pusty (czylnie wskazuje na ¿adne dane). Dlatego, aby zabezpieczyæ przed u¿ywaniem pamiêci, która nie zosta³a nam przydzielona nale¿y zaraz po wywo³aniu tej funkcjsprawdziæ wartoœæ, która zosta³¹ zwrócona. Dokonujemy tego w nastêpnej linijce. W naszym przypadku w sytuacji, gdy przydzia³ pamiêcnie by³ mo¿liwy wypisujemy tylko na ekranie odpowiednkomunikat wychodzimy z programu. Program mo¿emy zakoñczyæ w dowolnym momencie przy u¿yciu funkcjexit . Jedynym jej parametrem jest kod wyjœcia, który zostanie przekazany do systemu operacyjnego. W przypadku, gdy nasz program nie bêdzie u¿ywany w plikach wsadowych nie jest on wa¿ny. Skoro ju¿ uda³o nam przydzieliæ pamiêæ jesteœmy tego pewnto musimy wpisaæ do niej jakieœ dane. W naszym programie bêd¹ to dane o pracownikach naszej firmy. Przypisania dokonujemy w taksposób jak przedstawione to by³o w poprzednich podpunktach. W nastêpnych trzech linijkach programu wyœwietlamy dopiero co wpisane dane. Zauwa¿ tu, ¿e mimo tego, ¿e zmienna kadra jest wskaŸnikiem to uŸywamy jej tu tak samo jakby by³a tablic¹. Wynika to z zale¿noœcmiêdzy wskaŸnikama tablicamprzedstawionymw jednym z poprzednich podpunktów kursu. W ostatniej linijce programu mamy do czynienia z drug¹ wiêksz¹ nowoœci¹ - funkcj¹ free . Funkcja ta zwraca do systemu przydzielona wczeœniej przy pomocy funkcjmalloc pamiêæ. Mimo, ¿e w tym przypadku nie musieliœmy tego robiæ bo przy wyjœciu z programu pamiêæ ta zosta³aby automatycznie zwrócona, to jednak do dobrego zwyczaju programistycznego nale¿y zwrócenie wszystkich zaalokowanych zasobów. Pamiêtaj, ¿e po zwolnieniu pamiêcnie mo¿esz ju¿ u¿ywaæ tego obszaru pamiêc! Teoretycznie mo¿esz go modyfikowaæ (bo ci¹gle masz do niego wskaŸnik), ale nie powienineœ, gdy¿ system operacyjny móg³ przydzieliæ t¹ pamiêæ innemu programowtakie grzebanie po zasobach drugiego programu mo¿e zakoñczyæ tym, ¿e program ten (lub nawet ca³y system) zawiesi. W systemach operacyjnych z ochron¹ pamiêcnatomist mo¿e to spowodowaæ b³¹d ochrony niekontrolowane wyjœcie z twojego programu z b³êdem. 




2


